# See if replica restarts the transaction after failing on an InnoDB deadlock error.

# Note: testing what happens when too many retries is possible, but
# needs large waits when running with --debug, so we don't do it.
# The same way, this test may not test what is expected when run
# under Valgrind, timings are too short then (with --valgrind I
# (Guilhem) have seen the test manage to provoke lock wait timeout
# error but not deadlock error; that is ok as code deals with the two
# errors in exactly the same way.

--source include/primary-replica.inc

#create a new connection  to the replica
--connect (replica2, 127.0.0.1, root, ,test, $REPLICA_MYPORT,)

# 0) Prepare tables and data
--echo *** Prepare tables and data ***

connection primary;
eval CREATE TABLE t1 (a INT NOT NULL, KEY(a)) ENGINE=$engine_type;
eval CREATE TABLE t2 (a INT) ENGINE=$engine_type;
eval CREATE TABLE t3 (a INT NOT NULL, KEY(a)) ENGINE=$engine_type;
sync_replica_with_primary;

SHOW CREATE TABLE t1;
SHOW CREATE TABLE t2;
SHOW CREATE TABLE t3;
SELECT @@GLOBAL.replica_transaction_retries;
SELECT @@GLOBAL.innodb_lock_wait_timeout;
--source include/stop_replica.inc

connection primary;
# Save position of BEGIN
let $primary_pos_begin= query_get_value(SHOW PRIMARY STATUS, Position, 1);
BEGIN;
INSERT INTO t1 VALUES (1);
# We make a long transaction here
INSERT INTO t2 VALUES (2), (2), (2), (2), (2), (2), (2), (2), (2), (2);
INSERT INTO t3 VALUES (3);
COMMIT;
save_primary_pos;
--echo

# 1) Test deadlock
# Block replica SQL thread, wait retries of transaction, unlock replica before lock timeout
--echo *** Test deadlock ***

connection replica;
BEGIN;
SELECT * FROM t1 FOR UPDATE;
# Save variable 'Replica_retried_transactions' before deadlock
let $replica_retried_transactions= query_get_value(SHOW GLOBAL STATUS LIKE 'Replica_retried_transactions', Value, 1);
--connection replica2
--source include/start_replica.inc
--connection replica
# Wait until SQL thread blocked: variable 'Replica_retried_transactions' will incremented
let $status_var= Replica_retried_transactions;
let $status_var_value= $replica_retried_transactions;
let $status_type= GLOBAL;
let $status_var_comparsion= >;
--source include/wait_for_status_var.inc
SELECT COUNT(*) FROM t2;
COMMIT;

--echo
--echo # Test that the performance schema coulumn shows > 0 values.
--echo

--let $assert_text= current number of retries should be more than the value saved before deadlock.
--let $assert_cond= [SELECT COUNT_TRANSACTIONS_RETRIES FROM performance_schema.replication_applier_status, COUNT_TRANSACTIONS_RETRIES, 1] > "$replica_retried_transactions"
--source include/assert.inc

source include/check_replica_is_running.inc;
sync_with_primary;

# Check the data
SELECT * FROM t1;
SELECT * FROM t3;
--echo

# 2) Test lock wait timeout
# Block replica and wait lock timeout error
--echo *** Test lock wait timeout ***

connection replica;
--source include/stop_replica.inc
DELETE FROM t2;
# Set replica position to the BEGIN log event
RESET PRIMARY;
--replace_result $primary_pos_begin PRIMARY_POS_BEGIN
eval CHANGE PRIMARY TO PRIMARY_LOG_POS=$primary_pos_begin;
BEGIN;
# Hold lock
SELECT * FROM t1 FOR UPDATE;
# Wait until replica stopped with error 'Lock wait timeout exceeded'
--connection replica2
START REPLICA;
--connection replica
let $replica_sql_errno= 1205;
--source include/wait_for_replica_sql_error.inc
SELECT COUNT(*) FROM t2;
COMMIT;
--source include/start_replica.inc
sync_with_primary;
# Check data from tables
SELECT * FROM t1;
SELECT * FROM t3;
# Check that no error is reported
source include/check_replica_is_running.inc;
--echo

# 3) Test lock wait timeout and purged relay log
# Set max_relay_log_size=0, block replica and wait lock timeout error.
# Restart replica and check that no erros appear
--echo *** Test lock wait timeout and purged relay logs ***

connection replica;
SET @my_max_relay_log_size= @@global.max_relay_log_size;
SET global max_relay_log_size=0;
--source include/stop_replica.inc
DELETE FROM t2;
# Set replica position to the BEGIN log event
RESET PRIMARY;
--replace_result $primary_pos_begin PRIMARY_POS_BEGIN
eval CHANGE PRIMARY TO PRIMARY_LOG_POS=$primary_pos_begin; 
BEGIN;
# Hold lock
SELECT * FROM t1 FOR UPDATE;
# Wait until replica stopped with error 'Lock wait timeout exceeded'
--connection replica2
START REPLICA;
--connection replica
let $replica_sql_errno= 1205;
--source include/wait_for_replica_sql_error.inc
SELECT COUNT(*) FROM t2;
COMMIT;
--source include/start_replica.inc
sync_with_primary;
# Check data from tables
SELECT * FROM t1;
SELECT * FROM t3;
# Check that no error is reported
source include/check_replica_is_running.inc;
--echo

#
# bug#11748510/36524 incident of deadlock on replica is overdramatized
#
# Observe that the replica stopped when the number of transation retries 
# exceeds @@global.replica_transaction_retries
#
connection primary;

--echo *** Test the deadlock warning to be escalated into the error ***

delete from t1;
delete from t2;
delete from t3;

sync_replica_with_primary;

# make sure replica's unilateral row gone as well
delete from t1;
delete from t2;
delete from t3;

# the first attempt to run a deadlock scenario of p 1) leads to the error
set @save.replica_transaction_retries= @@global.replica_transaction_retries;
set @@global.replica_transaction_retries= 0;
source include/stop_replica.inc;

connection primary;

BEGIN;
INSERT INTO t1 VALUES (1);
# We make a long transaction here
INSERT INTO t2 VALUES (2), (2), (2), (2), (2), (2), (2), (2), (2), (2);
INSERT INTO t3 VALUES (3);
COMMIT;

connection replica;
BEGIN;
SELECT count(*) as zero FROM t1 FOR UPDATE;

--connection replica2
START REPLICA;
--connection replica

--echo *** Now the replica must be stopped due to timeout ***

let $replica_sql_errno= 1205; # ER_LOCK_TIMEOUT
let $show_replica_sql_error= 0;
source include/wait_for_replica_sql_error.inc;

rollback;

set @@global.replica_transaction_retries= @save.replica_transaction_retries;
source include/start_replica.inc;
# Clean up
--echo *** Clean up ***
connection primary;
DROP TABLE t1,t2,t3;
sync_replica_with_primary;
SET global max_relay_log_size= @my_max_relay_log_size;
CALL mtr.add_suppression(".*worker thread retried transaction.*");
CALL mtr.add_suppression(".*The replica coordinator and worker threads are stopped.*");
--echo End of 5.1 tests
--source include/rpl_end.inc
