#
# Bug#6148 ()
#
# Let the primary do lots of insertions
--source include/have_myisam.inc

if (0) { # to be fixed in other bug
connection primary;
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT");

connection replica;
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT");

connection primary;
create table t1(n int);
sync_replica_with_primary;
stop replica;
--source include/wait_for_replica_to_stop.inc
connection primary;
let $1=2500;
disable_query_log;
while ($1)
{
 eval insert into t1 values($1);
 dec $1;
}
enable_query_log;
save_primary_pos;

connection replica;
start replica;
let $wait_condition= SELECT COUNT(*) > 0 FROM t1;
source include/wait_condition_or_abort.inc;
stop replica io_thread;
start replica io_thread;
source include/wait_for_replica_to_start.inc;
sync_with_primary;

connection primary;
drop table t1;
sync_replica_with_primary;
}# if(0)

#
# Bug#38205 Row-based Replication (RBR) causes inconsistencies...
# Bug#319   if while a non-transactional replica is replicating a transaction...
#
# Verifying that STOP REPLICA does not interrupt excution of a group
# execution of events if the group can not roll back.
# Killing the sql thread continues to provide a "hard" stop (the
# part II, moved to the bugs suite as it's hard to make it
# deterministic with KILL).
#

#
# Part I. The being stopped sql thread finishes first the current group of 
#         events if the group contains an event on a non-transaction table.

connection primary;
create table t1i(n int primary key) engine=innodb;
create table t2m(n int primary key) engine=myisam;
begin;
insert into t1i values (1);
insert into t1i values (2);
insert into t1i values (3);
commit;

sync_replica_with_primary;
connection replica;
begin;
insert into t1i values (5);

connection primary;
let $pos0_primary= query_get_value(SHOW PRIMARY STATUS, Position, 1);
begin;
insert into t1i values (4);
insert into t2m values (1); # non-ta update to process
insert into t1i values (5); # to block at. to be played with stopped
commit;

connection replica;
# replica sql thread must be locked out by the conn `replica' explicit lock
let $pos0_replica= query_get_value(SHOW REPLICA STATUS, Exec_Primary_Log_Pos, 1);
--disable_query_log
eval select $pos0_primary - $pos0_replica as zero;
--enable_query_log

connection replica1;
let $count= 1;
let $table= t2m;
source include/wait_until_rows_count.inc;
send stop replica;

connection replica;
rollback; # release the sql thread

connection replica1;
reap;
source include/wait_for_replica_to_stop.inc;
let $sql_status= query_get_value(SHOW REPLICA STATUS, Replica_SQL_Running, 1);
--echo *** sql thread is *not* running: $sql_status ***


connection primary;
let $pos1_primary= query_get_value(SHOW PRIMARY STATUS, Position, 1);

connection replica;

let $pos1_replica= query_get_value(SHOW REPLICA STATUS, Exec_Primary_Log_Pos, 1);

--echo *** the prove: the stopped replica has finished the current transaction ***

--disable_query_log
select count(*) as five from t1i;
eval select $pos1_primary - $pos1_replica as zero;
eval select $pos1_replica > $pos0_replica as one;
--enable_query_log

source include/start_replica.inc;

# clean-up
connection primary;
drop table t1i, t2m;

sync_replica_with_primary;

--echo #
--echo # Bug#56096 STOP REPLICA hangs if executed in parallel with user sleep
--echo #

--connection primary

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TABLE t1 (a INT );

sync_replica_with_primary;

--connection replica1
--echo # Replica1: lock table for synchronization
LOCK TABLES t1 WRITE;

--connection primary
--echo # Primary: insert into the table
INSERT INTO t1 SELECT SLEEP(4);

--connection replica
--echo # Replica: wait for the insert
let $wait_condition=
  SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST
  WHERE STATE = "Waiting for table metadata lock"
  AND INFO = "INSERT INTO t1 SELECT SLEEP(4)";
--source include/wait_condition_or_abort.inc

--echo # Replica: send replica stop
--send STOP REPLICA

--connection replica1
--echo # Replica1: wait for stop replica
let $wait_condition=
  SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST
  WHERE INFO = "STOP REPLICA";
--source include/wait_condition_or_abort.inc

--echo # Replica1: unlock the table
UNLOCK TABLES;

--connection replica
--echo # Replica: wait for the replica to stop
--reap
--source include/wait_for_replica_to_stop.inc

--echo # Start replica again
--source include/start_replica.inc

--echo # Clean up
--connection primary
DROP TABLE t1;
sync_replica_with_primary;

#
# bug#3593869-64035 attempt to read a member of event_coordinates
# referenced by NULL pointer crashes server.
# Testing how out of valid range position value is handled with an error.
#

--connection primary
RESET PRIMARY;
let $primary_pos= query_get_value(SHOW PRIMARY STATUS, Position, 1);
let $primary_pos= `SELECT $primary_pos + 1`;

--connection replica
--source include/stop_replica.inc
--replace_regex /[0-9]+/PRIMARY_POS/
eval CHANGE PRIMARY TO primary_log_pos=$primary_pos;

START REPLICA;
# ER_PRIMARY_FATAL_ERROR_READING_BINLOG 1236
--let $replica_param=Last_IO_Errno
--let $replica_param_value=1236
--source include/wait_for_replica_param.inc

--let $replica_field_result_replace= / at [0-9]*/ at XXX/
--let $status_items= Last_IO_Errno, Last_IO_Error
--source include/show_replica_status.inc

--source include/stop_replica.inc
RESET REPLICA;

--connection primary
RESET PRIMARY;

# Replica is stopped by bug#3593869-64035 tests.
