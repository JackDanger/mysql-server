#
# Auxiliary file which is used to test BUG#56118 
#
# Replica should apply all statements in the transaction before stop if any
# temporary table is created or dropped.
#
# USEAGE: 
# --let $tmp_table_stm= a SQL statement 
# --source extra/rpl_tests/rpl_stop_replica.test
#

if (!$tmp_table_stm)
{
  --echo \$tmp_table_stm is NULL
  --die $tmp_table_stm is NULL
}

--echo
--echo [ On Primary ]
connection primary;
BEGIN;
DELETE FROM t1;
eval $tmp_table_stm;
INSERT INTO t1 VALUES (1);
DROP TEMPORARY TABLE tt1;
COMMIT;

--echo
--echo [ On Replica ]
connection replica;

# To check if replica SQL thread is applying INSERT statement
let $show_statement= SHOW PROCESSLIST;
let $field= Info;
let $condition= LIKE 'INSERT%';
source include/wait_show_condition.inc;

send STOP REPLICA SQL_THREAD;

--echo
--echo [ On Replica1 ]
connection replica1;
--echo # To resume replica SQL thread
SET DEBUG_SYNC= 'now SIGNAL signal.continue';
# wait for the sql thread to come out of the
# waiting phase before resetting the signals
--let $wait_condition= select count(*)=0 from information_schema.processlist where state LIKE '%debug sync point%' and info LIKE '%INSERT INTO t1 VALUES (1)%'
--source include/wait_condition.inc
SET DEBUG_SYNC= 'RESET';

--echo
--echo [ On Replica ]
connection replica;
reap;
source include/wait_for_replica_sql_to_stop.inc;

--echo # Replica should stop after the transaction has committed.
--echo # So t1 on primary is same to t1 on replica.
--let $diff_tables= primary:t1, replica:t1
--source include/diff_tables.inc

connection replica;
START REPLICA SQL_THREAD;
source include/wait_for_replica_sql_to_start.inc;
