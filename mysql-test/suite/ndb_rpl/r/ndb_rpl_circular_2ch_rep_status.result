include/rpl_init.inc [topology=1->2,4->3]
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the primary info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the primary info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
include/rpl_connect.inc [creating primary]
include/rpl_connect.inc [creating primary1]
include/rpl_connect.inc [creating replica]
include/rpl_connect.inc [creating replica1]
include/rpl_start_replicas.inc
Cluster A servers have no epoch replication info
select count(1) from mysql.ndb_apply_status;
count(1)
0
Cluster A servers have no max replicated epoch value
Primary(1)
select variable_name, variable_value from information_schema.global_status
where variable_name='Ndb_replica_max_replicated_epoch';
variable_name	variable_value
NDB_REPLICA_MAX_REPLICATED_EPOCH	0
Primary1(3)
select variable_name, variable_value from information_schema.global_status
where variable_name='Ndb_replica_max_replicated_epoch';
variable_name	variable_value
NDB_REPLICA_MAX_REPLICATED_EPOCH	0
Make a change originating at Cluster A
Primary(1)
use test;
create table t1 (a int primary key, b varchar(100)) engine=ndb;
insert into t1 values (1, "Venice");
Allow it to propagate to Cluster B
Originate a second unrelated change at Cluster B, to allow us to wait for
reverse propagation in the testcase
Replica1 (4)
insert into t1 values (2, "Death");
Allow it to propagate to Cluster A
Observe new entry in ndb_apply_status on Cluster A
Primary (1)
select server_id from mysql.ndb_apply_status order by server_id;
server_id
1
4
Non-replica server on Cluster A will have no value for Max Replicated Epoch
select variable_name, variable_value from information_schema.global_status
where variable_name='Ndb_replica_max_replicated_epoch';
variable_name	variable_value
NDB_REPLICA_MAX_REPLICATED_EPOCH	0
Replica server on Cluster A has current value for Max Replicated Epoch
Primary1 (3)
Expect count 1
select
count(1)
from
information_schema.global_status,
mysql.ndb_apply_status
where
server_id = 1
and
variable_name='Ndb_replica_max_replicated_epoch'
    and
variable_value = epoch;
count(1)
1
Now wait for all replication to quiesce
Now swap replication channels around
include/rpl_stop_replicas.inc
include/rpl_change_topology.inc [new topology=2->1,3->4]
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the primary info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the primary info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
Get current primary status on Cluster A new primary (next pos in Binlog)
Primary1 (3)
Flush logs to ensure any pending update (e.g. reflected apply_status write row)
is skipped over.
flush logs;
Setup replica on Cluster B to use it
Replica1 (4)
Get current primary status on Cluster B new primary (next pos in Binlog)
Replica (2)
Flush logs to ensure any pending update (e.g. reflected apply_status write row)
is skipped over.
flush logs;
Setup replica on Cluster A to use it
Primary (1)
Primary (1)
Show that Cluster A Replica server (old primary) has no Max replicated epoch before receiving data
select variable_name, variable_value from information_schema.global_status
where variable_name='Ndb_replica_max_replicated_epoch';
variable_name	variable_value
NDB_REPLICA_MAX_REPLICATED_EPOCH	0
Primary1 (3)
Cluster A Primary server (old replica) has old Max replicated epoch
select
count(1)
from
information_schema.global_status,
mysql.ndb_apply_status
where
server_id = 1
and
variable_name='Ndb_replica_max_replicated_epoch'
    and
variable_value = epoch;
count(1)
1
Now start replicas up
include/rpl_start_replicas.inc
Show that applying something from Cluster B causes the
old Max Rep Epoch to be loaded from ndb_apply_status
There is no new Max Rep Epoch from Cluster A as it has not changed
anything yet
Replica (2)
insert into test.t1 values (3, "From the Sea");
Allow to propagate to Cluster A
Primary (1)
New Replica server on Cluster A has loaded old Max-Replicated-Epoch
select server_id from mysql.ndb_apply_status order by server_id;
server_id
1
2
4
select
@result:=count(1)
from
information_schema.global_status,
mysql.ndb_apply_status
where
server_id = 1
and
variable_name='Ndb_replica_max_replicated_epoch'
    and
variable_value = epoch;
@result:=count(1)
1
Now make a new Cluster A change and see that the Max Replicated Epoch advances
once it has propagated
Primary1 (3)
insert into test.t1 values (4, "Brooke");
Propagate to Cluster B
Make change on Cluster B to allow waiting for reverse propagation
Replica (2)
insert into test.t1 values (5, "Rupert");
Wait for propagation back to Cluster A
Primary (1)
Show that Cluster A now has 2 different server_id entries in ndb_apply_status
Those from the new primary (server_id 3) are highest.
select server_id from mysql.ndb_apply_status order by server_id;
server_id
1
2
3
4
select
count(1)
from
information_schema.global_status,
mysql.ndb_apply_status
where
server_id = 3
and
variable_name='Ndb_replica_max_replicated_epoch'
    and
variable_value = epoch;
count(1)
1
local_server_with_max_epoch
3
Done
drop table t1;
include/rpl_stop_replicas.inc
CHANGE PRIMARY TO IGNORE_SERVER_IDS= ();
CHANGE PRIMARY TO IGNORE_SERVER_IDS= ();
CHANGE PRIMARY TO IGNORE_SERVER_IDS= ();
CHANGE PRIMARY TO IGNORE_SERVER_IDS= ();
include/rpl_start_replicas.inc
include/rpl_end.inc
