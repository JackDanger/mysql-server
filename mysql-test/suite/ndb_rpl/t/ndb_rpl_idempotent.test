# The include statement below is a temp one for tests that are yet to
#be ported to run with InnoDB,
#but needs to be kept for tests that would need MyISAM in future.
--source include/force_myisam_default.inc

--source include/have_ndb.inc
--source include/have_binlog_format_mixed_or_row.inc
--source suite/ndb_rpl/ndb_primary-replica.inc

#
# Currently test only works with ndb since it retrieves "old"
# binlog positions with mysql.ndb_binlog_index and ndb_apply_status;
#

# create a table with one row
CREATE TABLE t1 (c1 CHAR(15), c2 CHAR(15), c3 INT, PRIMARY KEY (c3)) ENGINE = NDB ;

# Replicate the table creation, then reset the primary log and
# replica to avoid the creation being replayed below
#
sync_replica_with_primary;
--connection replica
STOP REPLICA;
--connection primary
RESET PRIMARY;
--connection replica
RESET REPLICA;
START REPLICA;
--connection primary

INSERT INTO t1 VALUES ("row1","will go away",1);
SELECT * FROM t1 ORDER BY c3;

# sync replica and retrieve epoch
sync_replica_with_primary;
--replace_column 1 <the_epoch>
SELECT @the_epoch:=MAX(epoch) FROM mysql.ndb_apply_status;
let $the_epoch= `select @the_epoch` ;
SELECT * FROM t1 ORDER BY c3;

# get the primary binlog pos from the epoch
connection primary;
--disable_query_log
--disable_result_log
eval SELECT @the_pos:=Position,
   @the_file:=SUBSTRING_INDEX(REPLACE(FILE,'\\\\','/'), '/', -1)
   FROM mysql.ndb_binlog_index WHERE epoch = $the_epoch ;
let $the_pos= `SELECT @the_pos` ;
let $the_file= `SELECT @the_file` ;
let $the_epoch=`SELECT MAX(epoch) FROM mysql.ndb_apply_status`;
--enable_result_log
--enable_query_log

# insert some more values
INSERT INTO t1 VALUES ("row2","will go away",2),("row3","will change",3),("row4","D",4);
DELETE FROM t1 WHERE c3 = 1;
UPDATE t1 SET c2="should go away" WHERE c3 = 2;
UPDATE t1 SET c2="C" WHERE c3 = 3;
DELETE FROM t1 WHERE c3 = 2;

SELECT * FROM t1 ORDER BY c3;

# check that we have it on the replica
--sync_replica_with_primary
SELECT * FROM t1 ORDER BY c3;

source include/check_replica_is_running.inc;

# stop replica and reset position to before the last changes
STOP REPLICA;
--disable_query_log
--disable_result_log
eval CHANGE PRIMARY TO
  primary_log_file = '$the_file',
  primary_log_pos = $the_pos ;
--enable_result_log
--enable_query_log

source include/check_replica_no_error.inc;

call mtr.add_suppression("NDB Replica : At SQL thread start applying epoch .*");

# start the replica again
# -> same events should have been applied again
# e.g. inserting rows that already there
#      deleting a row which is not there
#      updating a row which is not there
START REPLICA;

--connection primary
SELECT * FROM t1 ORDER BY c3;
--sync_replica_with_primary
SELECT * FROM t1 ORDER BY c3;

STOP REPLICA;

#
# cleanup
#
--connection primary
DROP TABLE t1;
RESET primary;
--connection replica
DROP TABLE t1;
RESET replica;

START REPLICA;

#
# Test that we can handle update of a row that does not exist on the replica
# will trigger usage of AO_IgnoreError on replica side so that the INSERT
# still succeeds even if the replication of the UPDATE generates an error.
#
--connection primary
CREATE TABLE t1 (c1 CHAR(15) NOT NULL, c2 CHAR(15) NOT NULL, c3 INT NOT NULL, PRIMARY KEY (c3)) ENGINE = NDB ;
INSERT INTO t1 VALUES ("row1","remove on replica",1);

--sync_replica_with_primary
--connection replica
DELETE FROM t1;

--connection primary
BEGIN;
UPDATE t1 SET c2="does not exist" WHERE c3=1;
INSERT INTO t1 VALUES ("row2","new on replica",2);
COMMIT;

--sync_replica_with_primary
--connection replica
SELECT * FROM t1;
source include/check_replica_is_running.inc;

connection primary;
DROP TABLE IF EXISTS t1;

#
# Test that the ndb_binlog_index table records
# the start position of an epoch transaction
# as the first position after the previous
# epoch transaction
#
--sync_replica_with_primary
--connection replica
STOP REPLICA;
--connection primary
RESET PRIMARY;
--connection replica
RESET REPLICA;
START REPLICA;
--connection primary

--echo Let's interleave some DDL and DML in the Binlog

--echo   Some DDL
create table t1(a int primary key) engine=ndb;

--echo   First epoch transaction
begin;
insert into t1 values (1), (2), (3);
commit;

--echo Sync replica and retrieve epoch
--sync_replica_with_primary
--replace_column 1 <first_epoch>
SELECT @first_epoch:=MAX(epoch) FROM mysql.ndb_apply_status;
let $first_epoch= `select @first_epoch` ;

--echo   Replica contents
select * from t1 ORDER by a;

--echo   Get the next primary binlog pos from the epoch
connection primary;
--disable_query_log
--disable_result_log
eval SELECT @the_pos:=next_position,
   @the_file:=SUBSTRING_INDEX(REPLACE(next_file,'\\\\','/'), '/', -1)
   FROM mysql.ndb_binlog_index WHERE epoch = $first_epoch ;
let $the_pos= `SELECT @the_pos` ;
let $the_file= `SELECT @the_file` ;
--enable_result_log
--enable_query_log

--echo  Now let's do some more DDL and DML
create table t2 (a int primary key) engine=ndb;

begin;
insert into t2 values (1), (2), (3);
commit;

--sync_replica_with_primary

--connection replica
source include/check_replica_is_running.inc;

--echo   Stop replica and reset position to start of the applied epoch
STOP REPLICA;
--disable_query_log
--disable_result_log

eval CHANGE PRIMARY TO
  primary_log_file = '$the_file',
  primary_log_pos = $the_pos;

--enable_result_log
--enable_query_log

source include/check_replica_no_error.inc;

# Add a suppression for the warning that will appear in the
# Replica's .err file
call mtr.add_suppression("Replica: Table \'t2\' already exists .*");
call mtr.add_suppression("Replica SQL for channel '': Error \'Table \'t2\' already exists\' .*");


START REPLICA;

--let $replica_sql_errno= 1050
--let $show_replica_sql_error=1
--source include/wait_for_replica_sql_error.inc

STOP REPLICA;

# Cleanup
--connection primary
RESET PRIMARY;

--connection replica
RESET REPLICA;
START REPLICA;

--connection primary
DROP TABLE t1;
DROP TABLE t2;

--sync_replica_with_primary

# End of 5.1 Test
--source include/rpl_end.inc
