include/primary-replica.inc
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the primary info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
[connection primary]
# Using MyISAM storage engine
## Running the test with the SQL thread stopped
[connection replica]
include/stop_replica_sql.inc
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset_on_retrieved.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=MYISAM;
CREATE TABLE t2 (i INT) ENGINE=MYISAM;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=6, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=6, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
DROP TABLE t1,t2;
## Starting and syncing the SQL thread before next round
[connection replica]
include/start_replica_sql.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
## Running the test with the SQL thread started
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=MYISAM;
CREATE TABLE t2 (i INT) ENGINE=MYISAM;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=6, only_count=0]
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=6, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection primary]
DROP TABLE t1,t2;
include/sync_replica_sql_with_primary.inc
# Using InnoDB storage engine
## Running the test with the SQL thread stopped
[connection replica]
include/stop_replica_sql.inc
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset_on_retrieved.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=INNODB;
CREATE TABLE t2 (i INT) ENGINE=INNODB;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=4, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=4, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_xid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_xid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 4 + 1);
SET @val= 100 * 4 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_xid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 4 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
DROP TABLE t1,t2;
## Starting and syncing the SQL thread before next round
[connection replica]
include/start_replica_sql.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
## Running the test with the SQL thread started
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=INNODB;
CREATE TABLE t2 (i INT) ENGINE=INNODB;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=4, only_count=0]
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=4, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_xid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_xid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 4 + 1);
SET @val= 100 * 4 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_xid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 4 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection primary]
DROP TABLE t1,t2;
include/sync_replica_sql_with_primary.inc
[connection replica]
include/stop_replica.inc
RESET PRIMARY;
RESET REPLICA;
[connection primary]
RESET PRIMARY;
[connection replica]
include/stop_replica.inc
Warnings:
Note	3084	Replication thread(s) for channel '' are already stopped.
CHANGE PRIMARY TO PRIMARY_AUTO_POSITION= 0;
include/start_replica.inc
# Using MyISAM storage engine without auto positioning
## Running the test with the SQL thread stopped
[connection replica]
include/stop_replica_sql.inc
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset_on_retrieved.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=MYISAM;
CREATE TABLE t2 (i INT) ENGINE=MYISAM;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=6, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=6, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=3, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
DROP TABLE t1,t2;
## Starting and syncing the SQL thread before next round
[connection replica]
include/start_replica_sql.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
## Running the test with the SQL thread started
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=MYISAM;
CREATE TABLE t2 (i INT) ENGINE=MYISAM;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=6, only_count=0]
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=6, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=3, only_count=0]
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection primary]
DROP TABLE t1,t2;
include/sync_replica_sql_with_primary.inc
# Using InnoDB storage engine without auto positioning
## Running the test with the SQL thread stopped
[connection replica]
include/stop_replica_sql.inc
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset_on_retrieved.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=INNODB;
CREATE TABLE t2 (i INT) ENGINE=INNODB;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=4, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_io_with_primary.inc
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert_on_retrieved.inc [count=4, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_xid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_xid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 4 + 1);
SET @val= 100 * 4 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_xid_log_event' from @@GLOBAL.debug
include/gtid_step_assert_on_retrieved.inc [count=2, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
INSERT INTO t2 VALUES (100 * 4 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_io_with_primary.inc
include/gtid_step_assert_on_retrieved.inc [count=1, only_count=0]
Asserting based on SHOW REPLICA STATUS(Retrieved_Gtid_Set)
[connection primary]
DROP TABLE t1,t2;
## Starting and syncing the SQL thread before next round
[connection replica]
include/start_replica_sql.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
## Running the test with the SQL thread started
[connection replica]
[connection primary]
[connection replica]
include/gtid_step_reset.inc
[connection primary]
CREATE TABLE t1 (i INT NOT NULL AUTO_INCREMENT PRIMARY KEY, info VARCHAR(64)) ENGINE=INNODB;
CREATE TABLE t2 (i INT) ENGINE=INNODB;
INSERT INTO t1 (info) VALUE ('Insert data without splitting transactions in the relay log');
BEGIN;
INSERT INTO t2 (i) VALUES (-6);
INSERT INTO t2 (i) VALUES (-5);
INSERT INTO t2 (i) VALUES (-4);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=4, only_count=0]
[connection primary]
INSERT INTO t1 (info) VALUE ('Insert data rotating primary binlog between two transactions');
BEGIN;
INSERT INTO t2 (i) VALUES (-3);
INSERT INTO t2 (i) VALUES (-2);
COMMIT;
FLUSH LOGS;
INSERT INTO t1 (info) VALUE ('After FLUSH LOGS at primary');
BEGIN;
INSERT INTO t2 (i) VALUES (-1);
INSERT INTO t2 (i) VALUES (0);
COMMIT;
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection replica]
include/stop_replica_io.inc
include/start_replica_io.inc
[connection replica]
include/gtid_step_assert.inc [count=4, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_gtid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_gtid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 1 + 1);
SET @val= 100 * 1 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_gtid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 1 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_query_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_query_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 2 + 1);
SET @val= 100 * 2 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_query_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 2 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_table_map_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_table_map_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 3 + 1);
SET @val= 100 * 3 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_table_map_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 3 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection replica]
[connection primary]
INSERT INTO t1 (info) VALUES ('stop_io_after_reading_xid_log_event');
include/sync_replica_io_with_primary.inc
# Adding debug point 'stop_io_after_reading_xid_log_event' to @@GLOBAL.debug
[connection primary]
BEGIN;
INSERT INTO t2 VALUES (100 * 4 + 1);
SET @val= 100 * 4 + 2;
INSERT INTO t2 VALUES (@val);
COMMIT;
[connection replica]
include/wait_for_replica_io_to_stop.inc
# Removing debug point 'stop_io_after_reading_xid_log_event' from @@GLOBAL.debug
include/sync_replica_sql_with_io.inc
include/gtid_step_assert.inc [count=2, only_count=0]
[connection primary]
INSERT INTO t2 VALUES (100 * 4 + 3);
[connection replica]
include/start_replica_io.inc
[connection primary]
include/sync_replica_sql_with_primary.inc
include/gtid_step_assert.inc [count=1, only_count=0]
[connection primary]
include/sync_replica_sql_with_primary.inc
include/diff_tables.inc [primary:t1, replica:t1]
[connection primary]
DROP TABLE t1,t2;
include/sync_replica_sql_with_primary.inc
[connection replica]
include/stop_replica.inc
CHANGE PRIMARY TO PRIMARY_AUTO_POSITION= 1;
include/start_replica.inc
include/rpl_end.inc
