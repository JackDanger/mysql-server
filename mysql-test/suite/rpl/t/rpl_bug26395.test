# ==== Purpose ====
#
# Tests that an autocommitted XA transaction where the primary crashes
# just before writing the XID log event is executed correctly.  The
# primary rolls back, so the replica should not execute statement.
#
# This test was previously part of rpl_ndb_transaction.test
#
#
# ==== Method ====
#
# We want primary to be alive so that it can replicate the statement to
# the replica. So in the test case, we must not crash the
# primary. Instead, we fake the crash by just not writing the XID event
# to the binlog. This is done by the @@debug='d,do_not_write_xid'
# flag. This, in turn, requires us to do 'source
# include/have_debug.inc'
#
# So, unlike if the primary had crashed, the primary *will* execute the
# statement. But the replica should not execute it. Hence, after the
# test is executed, the expected result on primary is a table with one
# row, and on replica a table with no rows.
#
# To simulate the replica correctly, we wait until everything up to but
# not including the XID is replicated. This has to be done with
# include/sync_replica_io_with_primary.inc, not sync_replica_with_primary,
# since the latter waits until the replica *SQL* thread has caught up
# with the primary's position, which it will never do.
#
#
# ==== Related bugs ====
#
# BUG#26395: if crash during autocommit update to transactional table on primary, replica fails

--source include/not_group_replication_plugin.inc
source include/have_innodb.inc;
# have_debug is needed since we use the @@debug variable on primary
source include/have_debug.inc;
source include/primary-replica.inc;

# test adapts simulation of incomplete transaction that MTS does not tolerate
# when is stopped. So it reacts with an error whereas the single-threaded is fine.
-- source include/not_mts_replica_parallel_workers.inc


--echo ==== Initialize ====

--echo [on primary]
--connection primary

CREATE TABLE tinnodb (a INT) ENGINE = INNODB;
SHOW CREATE TABLE tinnodb;

# do_not_write_xid stops the primary from writing an XID event.
set @old_debug= @@debug;
set @@debug= 'd,do_not_write_xid';


--echo ==== Test ====

# Save the position up to which the replica SQL thread should execute.
save_primary_pos;

# Execute query and check that the row made it to the table.
INSERT INTO tinnodb VALUES (1);
SELECT * FROM tinnodb ORDER BY a;

# Sync replica's IO thread.
--echo [on replica]
# After the implementation of the transaction boundary parser,
# this sync cannot use GTIDs or else sync will timeout because only
# GTIDs of fully replicated transactions are in the
# Retrieved_Gtid_Set of the replica and, as the last event of the
# transaction never arrives, syncing with GTIDs won't work.
--let ignore_gtids_on_sync= 1
source include/sync_replica_io_with_primary.inc;

# Sync replica's SQL thread.
sync_with_primary 0;

--echo ==== Verify results on replica ====

source include/stop_replica.inc;

--let $status_items=Replica_IO_State,Last_SQL_Error,Last_IO_Error
--source include/show_replica_status.inc

--let $assert_text= Assert that the replica table has no rows
--let $assert_cond= `SELECT COUNT(*) = 0 FROM tinnodb`
--source include/assert.inc

--echo ==== Clean up ====

# Easiest to clean up primary and replica separately, without
# replication, since primary and replica are out of sync.

--echo [on primary]
connection primary;
DROP TABLE tinnodb;
set @@debug= @old_debug;

--echo [on replica]
connection replica;
DROP TABLE tinnodb;

# Warning: do not add more tests here. The binlog is in a bad state.
--let $rpl_only_running_threads= 1
--source include/rpl_end.inc
