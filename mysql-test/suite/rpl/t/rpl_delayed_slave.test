# ==== Purpose ====
#
# Test the time-delayed replication feature, i.e.,
# CHANGE PRIMARY TO PRIMARY_DELAY=X:
#
#  - Verify that replica has executed the events after but not before the
#    delay timeout.
#
#  - Verify that delay is correct when replica is already lagging
#    due to slow queries.
#
#  - Verify that Seconds_Behind_Primary is greater than or equal to the
#    delay if the replica still has unprocessed events in the relay log
#    and more time than the delay has elapsed since the last event was
#    executed on the primary.
#
#  - Verify that STOP REPLICA works instantly even during a delay, and
#    that it does not cause the waited-for event to be executed too
#    early on replica.
#
#  - Verify that changing back to no delay works.
#
#  - Verify that RESET REPLICA sets the delay to 0.
#
#  - Verify that setting a bad value for the delay gives an error.
#
# ==== Implementation ====
#
# We run the replica with 10 seconds lag.
#
# In general, to test that a query has not been executed by the replica
# before this time, we wait until the replica IO thread has received the
# event, and then 5 seconds more, and check that the table has not
# been updated.  To test that a query has been executed after this
# time, we wait 10 seconds more.
#
# To simulate that the replica lags due to slow queries, we invoke a
# stored function that executes SLEEP if @@server_id==2. This requires
# that we run with binlog_format=STATEMENT.
#
# ==== Related Bugs and Worklogs ====
#
# WL#344: Time-delayed replication
# BUG#28760: Simulating a replication lag
# [duplicate] BUG#22072: configurable delayed replication
# [duplicate] BUG#21639: Add Replication Delay parameter
# BUG#56442: Replica executes delayed statements when STOP REPLICA is issued
#
# ==== Issues with this Test Case ====
#
# The test is inherently timing-sensitive (i.e., contains races) and
# is likely to fail sporadically on a loaded host.
#
# The test takes a long time; it sleeps for around 20*10 seconds.

--source include/primary-replica.inc
# Needed so that sleeps get executed in the replica SQL thread.
--source include/have_binlog_format_statement.inc


call mtr.add_suppression("Unsafe statement written to the binary log using statement format");
--connection replica
call mtr.add_suppression("Unsafe statement written to the binary log using statement format");
--connection primary


# We assume that any simple operation takes zero time, with an error
# margin of $time1 seconds. Hence, if we run with a delay of $time2
# seconds, we expect that:
#  - If we execute a query on primary and wait $time1 seconds, then the
#    query has been copied to replica but not yet executed.
#  - If we execute a query on primary and wait $time3 seconds, then the
#    query has been executed.
--let $time1= 10
if ($max_query_execution_time) {
  --let $time1= $max_query_execution_time
}
--let $time2= `SELECT 2 * $time1`
--let $time3= `SELECT 3 * $time1`


--echo [on primary]
CREATE TABLE t1 (a VARCHAR(100), b INT);
INSERT INTO t1 VALUES ("zero", 0);


--echo ==== Normal setup ====

--echo [on replica]
--source include/sync_replica_sql_with_primary.inc

--source include/stop_replica.inc

--echo # CHANGE PRIMARY TO PRIMARY_DELAY = 2*T
--disable_query_log
eval CHANGE PRIMARY TO PRIMARY_DELAY = $time2;
--enable_query_log

--source include/start_replica.inc

--let $assert_text= SHOW REPLICA STATUS should return the same delay that we set with CHANGE PRIMARY
--let $assert_cond= [SHOW REPLICA STATUS, SQL_Delay, 1] = $time2
--source include/assert.inc

--echo [on primary]
--connection primary
INSERT INTO t1 VALUES ('normal setup', 1);

--let $query_number= 1
--source extra/rpl_tests/delayed_replica_wait_on_query.inc


--echo ==== Replica lags "naturally" after primary ====

--echo [on primary]
--connection primary

--disable_query_log
--echo # CREATE FUNCTION delay_on_replica(time_units INT) RETURNS INT BEGIN IF @@server_id = 2 THEN RETURN SLEEP(time_units * T); ELSE RETURN 0; END IF; END
--eval CREATE FUNCTION delay_on_replica(time_units INT) RETURNS INT BEGIN IF @@server_id = 2 THEN RETURN SLEEP(time_units * $time1); ELSE RETURN 0; END IF; END
--enable_query_log

INSERT INTO t1 SELECT delay_on_replica(3), 2;

--save_primary_pos
INSERT INTO t1 VALUES ('replica is already lagging: this statement should execute immediately', 3);
INSERT INTO t1 SELECT delay_on_replica(2), 4;

--echo [on replica]
--source include/sync_replica_io_with_primary.inc
--echo # sleep 1*T
--sleep $time1

--let $assert_text= No query executed
--let $assert_cond= MAX(b) = 1 FROM t1
--source include/assert.inc

--let $assert_text= Status should be 'Waiting until PRIMARY_DELAY...'
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" LIKE "Waiting until PRIMARY_DELAY%"
--source include/assert.inc

--echo # wait for first query to execute
--sync_with_primary

--echo # sleep 1*T
--sleep $time1

--let $assert_text= Second query executed
--let $assert_cond= MAX(b) = 3 FROM t1
--source include/assert.inc

--let $assert_text= Status should be executing third query (i.e., 'User sleep')
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" = "User sleep"
--source include/assert.inc

--echo # sleep 2*T
--sleep $time2

--let $assert_text= Third query executed
--let $assert_cond= MAX(b) = 4 FROM t1
--source include/assert.inc

--let $assert_text= Status should be 'Has read all relay log...'
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" LIKE "Replica has read all relay log%"
--source include/assert.inc


--echo ==== Seconds_Behind_Primary ====

--echo # Bring replica to sync.
--source include/stop_replica.inc
CHANGE PRIMARY TO PRIMARY_DELAY = 0;
--source include/start_replica.inc

--connection primary
INSERT INTO t1 VALUES ('Syncing replica', 5);
--source include/sync_replica_sql_with_primary.inc

--source include/stop_replica.inc
--echo # CHANGE PRIMARY TO PRIMARY_DELAY = 2*T
--disable_query_log
eval CHANGE PRIMARY TO PRIMARY_DELAY = $time2;
--enable_query_log
--source include/start_replica.inc

--connection primary
INSERT INTO t1 VALUES (delay_on_replica(1), 6);
--save_primary_pos
--connection replica

--echo # sleep 1*T
--sleep $time1

--let $assert_cond= [SHOW REPLICA STATUS, Seconds_Behind_Primary, 1] >= 0 AND <1> < $time2
--let $assert_text= Seconds_Behind_Primary should be between 0 and the 2*T
--source include/assert.inc

--echo # sleep 1*T
--sleep $time1

--let $assert_cond= [SHOW REPLICA STATUS, Seconds_Behind_Primary, 1] >= $time2
--let $assert_text= Seconds_Behind_Primary should be at least 2*T
--source include/assert.inc

--sync_with_primary


--echo ==== STOP REPLICA / START REPLICA + DML ====

# Set up a longer delay.
--source include/stop_replica.inc

--echo # CHANGE PRIMARY TO PRIMARY_DELAY = 3*T
--disable_query_log
eval CHANGE PRIMARY TO PRIMARY_DELAY = $time3;
--enable_query_log

--source include/start_replica.inc

--echo [on primary]
--connection primary
INSERT INTO t1 VALUES ('stop replica and start replica: DML', 7);

--echo [on replica]
--connection replica
--echo # sleep 1*T
--sleep $time1
--let $timestamp_before_stop= `SELECT UNIX_TIMESTAMP()`
--let $relay_log_pos_before_stop= query_get_value(SHOW REPLICA STATUS, Relay_Log_Pos, 1)
--source include/stop_replica.inc

--let $assert_text= STOP REPLICA should finish quickly, not wait for the ongoing sleep to finish
--let $assert_cond= UNIX_TIMESTAMP() - $timestamp_before_stop < $time1
--source include/assert.inc

--let $assert_text= SQL thread position should not increase after STOP REPLICA
--let $assert_cond= [SHOW REPLICA STATUS, Relay_Log_Pos, 1] = $relay_log_pos_before_stop
--source include/assert.inc

--let $assert_text= Query should not be executed after STOP REPLICA
--let $assert_cond= MAX(b) = 6 FROM t1
--source include/assert.inc

--let $assert_text= Status should be '' after STOP REPLICA
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" = ""
--source include/assert.inc

--source include/start_replica.inc

--let $assert_text= START REPLICA should finish quickly
--let $assert_cond= UNIX_TIMESTAMP() - $timestamp_before_stop < $time1
--source include/assert.inc

--let $query_number= 7
--source extra/rpl_tests/delayed_replica_wait_on_query.inc


--echo ==== STOP REPLICA / START REPLICA + DDL ====

--echo This verifies BUG#56442

--echo [on primary]
--connection primary
CREATE TABLE t_check_dml_not_executed_prematurely (a INT);
--source include/save_primary_pos.inc

--echo [on replica]
--connection replica
--echo # sleep 1*T
--sleep $time1

--let $timestamp_before_stop= `SELECT UNIX_TIMESTAMP()`
--let $relay_log_pos_before_stop= query_get_value(SHOW REPLICA STATUS, Relay_Log_Pos, 1)
--source include/stop_replica.inc

--let $assert_text= STOP REPLICA should finish quickly, not wait for the ongoing sleep to finish
--let $assert_cond= UNIX_TIMESTAMP() - $timestamp_before_stop < $time1
--source include/assert.inc

--let $assert_text= SQL thread position should not increase after STOP REPLICA
--let $assert_cond= [SHOW REPLICA STATUS, Relay_Log_Pos, 1] = $relay_log_pos_before_stop
--source include/assert.inc

--let $assert_text= Query should not be executed after STOP REPLICA
--let $assert_cond= COUNT(*) = 0 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = "t_check_dml_not_executed_prematurely"
--source include/assert.inc

--let $assert_text= Status should be '' after STOP REPLICA
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" = ""
--source include/assert.inc

--source include/start_replica.inc

--let $assert_text= START REPLICA should finish quickly
--let $assert_cond= UNIX_TIMESTAMP() - $timestamp_before_stop < $time1
--source include/assert.inc

--echo # sleep 1*T
--sleep $time1

--let $assert_text= DDL Query should not be executed after START REPLICA
--let $assert_cond= COUNT(*) = 0 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = "t_check_dml_not_executed_prematurely"
--source include/assert.inc

--let $assert_text= Status should be 'Waiting until PRIMARY_DELAY...'
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" LIKE "Waiting until PRIMARY_DELAY%"
--source include/assert.inc

--echo # sleep 1*T
--sleep $time1

--echo # sync with primary (with timeout 1*T)
--source include/sync_replica_sql.inc

--let $assert_text= DDL Query should be executed
--let $assert_cond= COUNT(*) = 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = "t_check_dml_not_executed_prematurely"
--source include/assert.inc

--let $assert_text= Status should be 'Has read all relay log...'
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" LIKE "Replica has read all relay log%"
--source include/assert.inc

--source include/check_replica_is_running.inc


--echo ==== Change back to no delay ====

--echo [on replica]
--connection replica
--source include/stop_replica.inc
CHANGE PRIMARY TO PRIMARY_DELAY = 0;

--let $assert_text= Delay should be 0 when we set it to 0
--let $assert_cond= [SHOW REPLICA STATUS, SQL_Delay, 1] = 0
--source include/assert.inc

--source include/start_replica.inc

--echo [on primary]
--connection primary
INSERT INTO t1 VALUES ('change back to no delay', 8);

--echo [on replica]
--source include/sync_replica_io_with_primary.inc
--echo # sleep 1*T
--sleep $time1

--let $assert_text= Query should be executed
--let $assert_cond= MAX(b) = 8 FROM t1
--source include/assert.inc

--let $assert_text= Status should be 'Replica has read all relay log...'
--let $assert_cond= "[SHOW REPLICA STATUS, Replica_SQL_Running_State, 1]" Like "Replica has read all relay log%"
--source include/assert.inc


--echo ==== Reset delay with RESET REPLICA ====

--source include/stop_replica.inc
CHANGE PRIMARY TO PRIMARY_DELAY = 71;
--source include/start_replica.inc

--let $assert_text= Delay should be 71 when we set it to 71
--let $assert_cond= [SHOW REPLICA STATUS, SQL_Delay, 1] = 71
--source include/assert.inc

--source include/stop_replica.inc
RESET REPLICA;
--echo [on primary]
--connection primary
RESET PRIMARY;
--echo [on replica]
--connection replica
--source include/start_replica.inc

--let $assert_text= Delay should be 0 after RESET REPLICA
--let $assert_cond= [SHOW REPLICA STATUS, SQL_Delay, 1] = 0
--source include/assert.inc


--echo ==== Set an invalid value for the delay ====

--source include/stop_replica.inc

--echo # Expect error for setting negative delay
--error ER_PARSE_ERROR
CHANGE PRIMARY TO PRIMARY_DELAY = -1;

--echo # Expect that it's ok to set delay of 2^31-1
CHANGE PRIMARY TO PRIMARY_DELAY = 2147483647;
--echo # Expect error for setting delay between 2^31 and 2^32-1
--error ER_PRIMARY_DELAY_VALUE_OUT_OF_RANGE
CHANGE PRIMARY TO PRIMARY_DELAY = 2147483648;

--echo # Expect error for setting delay to nonsense
--error ER_PARSE_ERROR
CHANGE PRIMARY TO PRIMARY_DELAY = blah;

# todo: CHANGE PRIMARY TO PRIMARY_DELAY = 999999999999999999999999999
# should give error

CHANGE PRIMARY TO PRIMARY_DELAY = 0;
--source include/start_replica.inc


--echo ==== Clean up ====

--echo [on primary]
--connection primary
DROP TABLE t1, t_check_dml_not_executed_prematurely;
DROP FUNCTION delay_on_replica;

--echo [on replica]
--source include/sync_replica_sql_with_primary.inc

--source include/rpl_end.inc
