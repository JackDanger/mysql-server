# ==== Purpose ====
#
# Test that the replica fails to connect to the primary with
# PRIMARY_AUTO_POSITION=1 if the replica is missing some transactions
# that the primary has purged.
#
# ==== Implementation ====
#
# Start primary and replica, then stop the replica. Generate a transaction
# on primary and purge it.  Verify that the replica fails if it tries to
# connect using CHANGE PRIMARY TO PRIMARY_AUTO_POSITION, but the replica
# succeeds if it tries to connect using CHANGE PRIMARY TO
# PRIMARY_LOG_POS.
#
# ==== References ====
#
# Added in WL#3584 - Global Transaction Identifiers

--source include/not_group_replication_plugin.inc
--source include/have_debug.inc
--source include/have_gtid.inc
--let $rpl_gtid_utils= 1
--source include/primary-replica.inc

call mtr.add_suppression("Got fatal error 1236 from primary when reading data from binary log: 'The replica is connecting using CHANGE PRIMARY TO PRIMARY_AUTO_POSITION = 1, but the primary has purged binary logs containing GTIDs that the replica requires.");

--echo ######## Initialize ########

--let $primary_uuid= `SELECT @@SERVER_UUID`
CREATE TABLE t1 (a INT) ENGINE = InnoDB;
--source include/sync_replica_sql_with_primary.inc
--source include/stop_replica.inc

--connection primary
# Need to kill the dump thread explicitly: stop replica does not do
# that, and if the dump thread is slow, it will still be reading from
# the old binlog at the time we do PURGE BINARY LOGS below. That would
# prevent PURGE BINARY LOGS from purging the log.
--source include/stop_dump_threads.inc

INSERT INTO t1 VALUES (1);

FLUSH LOGS;
--let $primary_file= query_get_value(SHOW PRIMARY STATUS, File, 1)
--let $primary_pos= query_get_value(SHOW PRIMARY STATUS, Position, 1)
INSERT INTO t1 VALUES (2);
eval PURGE BINARY LOGS TO '$primary_file';

--let $assert_cond= "[SHOW PRIMARY STATUS, File, 1]" = "$primary_file"
--let $assert_text= PURGE BINARY LOGS successfully removed all but the latest files
--source include/assert.inc

--let $primary_file= query_get_value(SHOW PRIMARY STATUS, File, 1)
--let $primary_pos= query_get_value(SHOW PRIMARY STATUS, Position, 1)
INSERT INTO t1 VALUES (2);
--save_primary_pos

--connection replica
CHANGE PRIMARY TO PRIMARY_AUTO_POSITION = 1;

START REPLICA;
# BUG#13727933 causes this test to fail sporadically on the following line
# apparently the binlog is not always purged on the primary (?)
--let $replica_io_errno= 1236 # ER_PRIMARY_FATAL_ERROR_READING_BINLOG
--source include/wait_for_replica_io_error.inc
--source include/stop_replica_sql.inc

--replace_result $primary_file PRIMARY_FILE
--replace_result $primary_pos PRIMARY_POS
eval CHANGE PRIMARY TO PRIMARY_LOG_FILE = '$primary_file', PRIMARY_LOG_POS = $primary_pos, PRIMARY_AUTO_POSITION = 0;

--source include/start_replica.inc
--sync_with_primary

--let $assert_text= t1 should contain only one row with the value 2
--let $assert_cond= "[SELECT COUNT(*) FROM t1]" = "1" AND "[SELECT * FROM t1]" = "2"
--source include/assert.inc

--echo ######## Clean up ########
--echo === Stop and reset replica/primary (connection replica) ====
--connection replica
--source include/stop_replica.inc
RESET PRIMARY;
RESET REPLICA;
--echo === Stop and reset primary (connection primary) ====
--connection primary
RESET PRIMARY;
--echo === Start replica (connection replica) ====
--connection replica
--source include/start_replica.inc
--echo === Sync replica with primary (connection primary/replica) ====
--connection primary
DROP TABLE t1;
--source include/sync_replica_sql_with_primary.inc

--connection primary
--source include/rpl_end.inc
