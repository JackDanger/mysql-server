###############################################################################
#Bug#19012085 SETTING GTID_PURGED MAY BREAK AUTO_POSITION AND THUS REPLICAS
# Problem:
#  When replica asks for GTIDs which were purged by Primary, Primary is silently
#  ignoring it and sending the GTIDs whatever is available.
# Fix:
#  Replica's I/O thread, when connecting to Primary, should be aborted with an
#  error "Primary has purged binary logs containing GTIDs that the replica
#  requires."
# Steps to reproduce:
#  1) Set GTID_PURGED=UUID:1-2 on Primary
#  2) Execute some dummy transactions (GTID:3-4)
#  3) A new replica request Primary to send GTIDs
#  4) Primary should throw error instead of silently sending GTIDs 3 and 4.
###############################################################################

--source include/not_group_replication_plugin.inc
--source include/have_gtid.inc
--source include/have_binlog_format_statement.inc
--let $rpl_skip_start_replica= 1
--source include/primary-replica.inc

# Step-1) Primary wants to set 1 and 2 GTIDs in GTID_PURGED
--let $primary_uuid= `SELECT @@GLOBAL.SERVER_UUID`
--replace_result $primary_uuid primary_uuid
--eval SET GLOBAL GTID_PURGED= "$primary_uuid:1-2"

# Step-2) Do some dummy transactions
CREATE TABLE t1(i INT);  # GTID-3
DROP TABLE t1;           # GTID-4

# Step-3) Start Replica IO thread which will request Primary to send all
# transactions.
--connection replica
START REPLICA IO_THREAD;

# Step-4)since Primary has already purged binary logs  containing GTID 1 and 2,
# it should throw error and I/O thread should not be started.
#1236 = ER_PRIMARY_FATAL_ERROR_READING_BINLOG
--let $replica_io_errno= 1236
--let $show_replica_io_error= 1
--source include/wait_for_replica_io_error.inc

# Fix the problem by setting GTID_PURGED on Replica as well.
--replace_result $primary_uuid primary_uuid
--eval SET GLOBAL GTID_PURGED= "$primary_uuid:1-2"

# Now start replica threads. Replica will ask Primary to send all GTIDs
# except GTID:1-2 which should not be a problem and should not throw
# any errors.
--source include/start_replica.inc
--connection primary
--source include/sync_replica_sql_with_primary.inc

--let $assert_text= Replica should be able to get GTID-3 and 4 now.
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$primary_uuid:1-4"
--source include/assert.inc

call mtr.add_suppression(".*Primary has purged binary logs containing GTIDs that the replica requires.*");

###############################################################################
#Bug #18789758  DATA INCONSISTENCIES WHEN PRIMARY HAS TRUNCATED BINARY LOG WITH
# GTID AFTER CRASH
# Problem:
#   Primary's dump thread is not detecting the case where Replica's gtid executed
#   set is having more gtids than Primary's gtid executed set with respective
#   to Primary's UUID.
# Fix:
#   If it happens, dump thread will be stopped during the handshake
#   with Replica(thus the Replica's I/O thread will be stopped with the
#   error). Otherwise, it can lead to data inconsistency
#   between Primary and Replica.
#
# Steps to reproduce:
#  1) Execute some sample gtid transactions on Primary
#  2) Let it reach Replica
#  3) Fake raid failure( by manually deleting binary log file)
#  4) Restart Primary, thus removing those gtids from executed gtid set.
#  5) Restart replica's I/O thread, Replica sends its gtids which are purged on
#      Primary
#  6) Make sure I/O thread gets error and informs the situation to the Replica.
#  7) Verify that situation is recovered back normal after setting GTID_PURGED
#      value to those purged gtids.
###############################################################################

# Cleanup from the next test script
--connection primary
--source include/rpl_reset.inc

# Step-1) Execute some sample gtid transactions on Primary
CREATE TABLE t1(i INT);
DROP TABLE t1;

# Step-2) Let it reach Replica.
--sync_replica_with_primary
--source include/stop_replica.inc

# Step-3) Fake raid failure( by manually deleting binary log file)
--connection primary
--let $primary_datadir= `SELECT @@datadir;`
FLUSH LOGS;
DELETE FROM mysql.gtid_executed;
--remove_file $primary_datadir/primary-bin.000001
--remove_file $primary_datadir/primary-bin.000002
--remove_file $primary_datadir/primary-bin.index

# Step-4) Restart Primary, thus removing those gtids from executed gtid set.
--let $rpl_server_number= 1
--source include/rpl_restart_server.inc
# Step-5) Restart replica's I/O thread, Replica sends its gtids which are purged on Primary
--connection replica
START REPLICA IO_THREAD;

# Step-6) Make sure I/O thread gets error and informs the situation to the Replica.
--let $replica_io_errno=1236
#convert_error(ER_PRIMARY_FATAL_ERROR_READING_BINLOG)
--let $show_replica_io_error= 1
--source include/wait_for_replica_io_error.inc
call mtr.add_suppression(".*Replica has more GTIDs than the primary has.*");

# Step-7) Verify that situation is recovered back normal after setting GTID_PURGED
#          value to those purged gtids.
--connection primary
--let $primary_uuid= `SELECT @@GLOBAL.SERVER_UUID`
--replace_result $primary_uuid primary_uuid
--eval SET GLOBAL GTID_PURGED= "$primary_uuid:1-2"

--connection replica
--source include/start_replica.inc

# Cleanup
--source include/rpl_end.inc
