--source include/not_gtid_enabled.inc
--source include/not_group_replication_plugin.inc
--source include/have_debug.inc
--source include/force_restart.inc
--source include/primary-replica.inc

CALL mtr.add_suppression("Generate an incident log event before writing the "
                         "real event to the binary log for testing purposes. "
                         "An incident event has been written to the binary "
                         "log which will stop the replicas.");

--let @old_debug= @@global.debug
SET GLOBAL DEBUG="+d,incident_database_resync_on_replace";

--echo **** On Primary ****
CREATE TABLE t1 (a INT);

INSERT INTO t1 VALUES (1),(2),(3);
SELECT * FROM t1;

# This will generate an incident log event and store it in the binary
# log before the replace statement.
REPLACE INTO t1 VALUES (4);
--save_primary_pos
SELECT * FROM t1;

connection replica;
# Wait until SQL thread stops with error LOST_EVENT on primary
call mtr.add_suppression("Replica SQL.*The incident LOST_EVENTS occured on the primary.* 1590");
let $replica_sql_errno= 1590;
let $show_replica_sql_error= 1;
source include/wait_for_replica_sql_error.inc;

# The 4 should not be inserted into the table, since the incident log
# event should have stop the replica.
--echo **** On Replica ****
SELECT * FROM t1;

SET GLOBAL SQL_REPLICA_SKIP_COUNTER=1;
START REPLICA;
--sync_with_primary

# Now, we should have inserted the row into the table and the replica
# should be running. We should also have rotated to a new binary log.

SELECT * FROM t1;
source include/check_replica_is_running.inc;

connection primary;
DROP TABLE t1;
SET GLOBAL DEBUG= @old_debug;

--sync_replica_with_primary
--source include/rpl_end.inc
