# ==== Purpose ====
#
# Test the behavior of replica when binlog_format=statement and a query
# that updates a non-transactional table is killed on the primary,
# after being only half-way completed.
#
# The following should hold:
# - The statement should be logged with error code ER_QUERY_INTERRUPTED.
# - The replica should normally stop with an error.
# - If the table or database is filtered out, the replica should not stop.
#
# To test this, we test three cases:
#  1. Killed query on primary generates error on replica.
#  2. Killed query on primary, on a filtered-out table, does not
#     generate error on replica.
#  3. Killed query on primary, on a table in a filtered-out database,
#     does not generate error on replica.
#
# ==== Implemenation ====
#
# For case 1, we extecute a statement and kill it in the middle, then
# verify that the replica stops with the correct error.
#
# For cases 2 and 3, we execute a statement and kill it in the middle,
# then verify that the replica replicates without problems.  In case 2,
# the statement is executed when the current database is filtered-out.
# In case 3, the statement modifies a table that is filtered-out.
#
# Replica filters are specified in rpl_kill_query.cnf
#
# The procedure to generate a killed statement is similar in all three
# cases.  See extra/rpl_tests/rpl_kill_query.inc for details.
#
# ==== References ====
#
# BUG#18145032: NO EMPTY TRANSACTION IS CREATED FOR A FILTERED CREATE TEMPORARY TABLE WITH GTIDS
# - Test created as part of this fix, since it touches the code for
#   filtering.

--source include/have_binlog_format_statement.inc
--source include/primary-replica.inc
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT");
CALL mtr.add_suppression("The replica coordinator and worker threads are stopped, possibly leaving data in inconsistent state");
--sync_replica_with_primary
--connection primary

--echo ==== Case 1: Killed query on primary -> error on replica ====

--let $database= db1
--let $table= t1
--source extra/rpl_tests/rpl_kill_query.inc

--echo ---- Verify there is an error on replica ----
--source include/sync_replica_io_with_primary.inc
--let $replica_sql_errno= convert_error(ER_ERROR_ON_PRIMARY)
--source include/wait_for_replica_sql_error.inc

--echo ---- Verify that nothing was inserted on replica -----
--let $assert_text= Nothing should be inserted on replica
--let $assert_cond= [replica:SELECT COUNT(*) FROM $database.t1] = 0
--source include/assert.inc

--echo ---- Clean up ----
--source include/stop_replica_io.inc
RESET REPLICA;
RESET PRIMARY;
DROP DATABASE db1;
--source include/rpl_connection_primary.inc
RESET PRIMARY;
--source include/rpl_connection_replica.inc
--source include/start_replica.inc
--source include/rpl_connection_primary.inc

--echo ==== Case 2: Primary kills query -> no error if replica filters by db ====

--let $database= ignored_db
--let $table= t1
--source extra/rpl_tests/rpl_kill_query.inc

--echo ---- Verify all was replicated ok ----
--source include/sync_replica_sql_with_primary.inc
--source include/rpl_connection_primary.inc

--echo ==== Case 3: Primary kills query -> no error if replica filters by table ====

--let $database= db1
--let $table= ignored_table
--source extra/rpl_tests/rpl_kill_query.inc

--echo ---- Verify all was replicated ok ----
--source include/sync_replica_sql_with_primary.inc

--source include/rpl_end.inc
