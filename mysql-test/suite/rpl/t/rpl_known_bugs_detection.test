# Test to see if replica can detect certain known bugs present
# on the primary, and appropriately decides to stop
# (assuming the bug is fixed in the replica, replica cannot of course
# imitate the bug, so it has to stop).

--source include/not_group_replication_plugin.inc
source include/have_debug.inc;
# because of pretend_version_50034_in_binlog the test can't run with checksum
source include/have_binlog_checksum_off.inc;
source include/primary-replica.inc;

call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.");

# Currently only statement-based-specific bugs are here
-- source include/have_binlog_format_statement.inc


#
# This is to test that replica properly detects if
# primary may suffer from:
# BUG#24432 "INSERT... ON DUPLICATE KEY UPDATE skips auto_increment values"
# (i.e. on primary, INSERT ON DUPLICATE KEY UPDATE is used and manipulates
# an auto_increment column, and is binlogged statement-based).
#

# testcase with INSERT VALUES
CREATE TABLE t1 (a INT NOT NULL PRIMARY KEY AUTO_INCREMENT, b INT,
UNIQUE(b));
--source include/sync_replica_sql_with_primary.inc
connection primary;
INSERT INTO t1(b) VALUES(1),(1),(2) ON DUPLICATE KEY UPDATE t1.b=10;
SELECT * FROM t1 order by 1;
connection replica;

call mtr.add_suppression("The replica coordinator and worker threads are stopped, possibly leaving data in inconsistent state");

--let $replica_sql_errno= convert_error(ER_UNKNOWN_ERROR)
call mtr.add_suppression("Replica SQL.*suffer.*http:..bugs.mysql.com.bug.php.id=24432");
--source include/wait_for_replica_sql_error.inc
# show that it was not replicated
SELECT * FROM t1 order by 1;

# restart replication for the next testcase
--let $rpl_only_running_threads= 1
--source include/rpl_reset.inc
--connection primary
DROP TABLE t1;

# testcase with INSERT SELECT
CREATE TABLE t1 (
  id bigint(20) unsigned NOT NULL auto_increment,
  field_1 int(10) unsigned NOT NULL,
  field_2 varchar(255) NOT NULL,
  field_3 varchar(255) NOT NULL,
  PRIMARY KEY (id),
  UNIQUE KEY field_1 (field_1, field_2)
);
CREATE TABLE t2 (
  field_a int(10) unsigned NOT NULL,
  field_b varchar(255) NOT NULL,
  field_c varchar(255) NOT NULL
);
INSERT INTO t2 (field_a, field_b, field_c) VALUES (1, 'a', '1a');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (2, 'b', '2b');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (3, 'c', '3c');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (4, 'd', '4d');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (5, 'e', '5e');
--source include/sync_replica_sql_with_primary.inc
connection primary;
# Updating table t1 based on values from table t2
INSERT INTO t1 (field_1, field_2, field_3)
SELECT t2.field_a, t2.field_b, t2.field_c
FROM t2
ON DUPLICATE KEY UPDATE
t1.field_3 = t2.field_c;
# Inserting new record into t2
INSERT INTO t2 (field_a, field_b, field_c) VALUES (6, 'f', '6f');
# Updating t1 again
INSERT INTO t1 (field_1, field_2, field_3)
SELECT t2.field_a, t2.field_b, t2.field_c
FROM t2
ON DUPLICATE KEY UPDATE
t1.field_3 = t2.field_c;
SELECT * FROM t1 order by 1;
connection replica;

--let $replica_sql_errno= convert_error(ER_UNKNOWN_ERROR)
--source include/wait_for_replica_sql_error.inc

# show that it was not replicated
SELECT * FROM t1 order by 1;
connection primary;

# clean up
drop table t1, t2;
connection replica;
drop table t1, t2;
# clear error message in sql thread
--source include/stop_replica_io.inc
RESET REPLICA;

# End of 5.0 tests
--let $rpl_only_running_threads= 1
--source include/rpl_end.inc
