################################################################################
# This test case checks if MTS allows to concurrently access the replication
# tables, and as such, concurrently commit transactions that update different
# databases.
#
# It does so by making the workers' threads to sleep after updating replication
# tables but before releasing locks and committing the current transaction.
################################################################################

--source include/not_gtid_enabled.inc
--source include/not_group_replication_plugin.inc
--source include/have_debug.inc
--source include/have_innodb.inc
# no format specific tests so we run it only in MIXED mode
--source include/have_binlog_format_mixed.inc
--source include/primary-replica.inc

--connection primary
CREATE DATABASE db_1;
CREATE DATABASE db_2;

CREATE TABLE db_1.test_1 (id INTEGER) engine=Innodb;
CREATE TABLE db_2.test_1 (id INTEGER) engine=Innodb;

--connection primary
--source include/sync_replica_sql_with_primary.inc

--connection replica
--source include/stop_replica.inc
set @save.replica_parallel_workers= @@global.replica_parallel_workers;
set @save.debug= @@global.debug;
SET @@global.replica_parallel_workers= 2;
ALTER TABLE mysql.replica_relay_log_info ENGINE= Innodb;
ALTER TABLE mysql.replica_worker_info ENGINE= Innodb;
--source include/start_replica.inc

--connection primary

# Create two replica side parallelizable transactions.
# Logical_Clock requires one more which is the first
# one in binlog as a warmup.
INSERT INTO db_1.test_1 VALUES(0);
--source include/sync_replica_sql_with_primary.inc
SET GLOBAL debug="d,mts_debug_concurrent_access";

--connection primary
BEGIN;
INSERT INTO db_1.test_1 VALUES(1);
--connection primary1
BEGIN;
INSERT INTO db_2.test_1 VALUES(1);
--connection primary
COMMIT;
--connection primary1
COMMIT;

DROP DATABASE db_1;
DROP DATABASE db_2;
--source include/sync_replica_sql_with_primary.inc

--source include/stop_replica.inc
SET @@global.replica_parallel_workers= @save.replica_parallel_workers;
SET @@global.debug= @save.debug;
--source include/start_replica.inc

#
# Bug#12964649 MTS memory not released
#
# Originally reported when opt_replica_checkpoint_group is set to be greater
# than sizeof(BLOB) * 8 - 1 Workers initialization code fails.
# VALID_RANGE() for opt_replica_checkpoint_group is fixed in bug12979420.
# 
# The current bug test simulates a failure to start by a Worker
# thread, checks the error, and verifies that all memory is released
# (valgrind proves, the user can watch top report).
#

connection replica;

call mtr.add_suppression('Error reading replica worker configuration');
call mtr.add_suppression('Failed during replica workers initialization');
call mtr.add_suppression('Failed during replica worker thread creation for channel ''');

source include/stop_replica.inc;
set @save.replica_checkpoint_group= @@global.replica_checkpoint_group;
set @save.replica_parallel_workers= @@global.replica_parallel_workers;

# The following assignment can work only with debug builds.
# It sets opt_replica_checkpoint_group to one more to its VALID_RANGE() maximum.
# set @@global.replica_checkpoint_group= 524280 + 1;

set @save.debug= @@global.debug;
SET @@global.debug= "d,mts_worker_thread_fails";
set @@global.replica_parallel_workers= 2;

start replica sql_thread;
--let $replica_sql_errno= 1593
source include/wait_for_replica_sql_error.inc;

set @@global.replica_checkpoint_group= @save.replica_checkpoint_group;
set @@global.replica_parallel_workers= @save.replica_parallel_workers;
set @@global.debug= @save.debug;

source include/start_replica.inc;

#
# BUG#13681205 : REPLICATION FAILS DURING REPLICA WORKERS INITIALIZATION, 
#                CRASHES REPLICA 
#
# This test checks that the replica starts correctly, even
# if we set the maximum of replica_checkpoint_group higher
# than the maximum (the server adjusts it to the proper
# value).                    
#
--connection primary
--source include/rpl_reset.inc

--connection replica
--source include/stop_replica.inc
call mtr.add_suppression("option 'replica_checkpoint_group': unsigned value 524281 adjusted to 524280");
call mtr.add_suppression("Failed during replica worker thread create");
call mtr.add_suppression("Replica SQL for channel '': Failed during replica workers initialization, Error_code: 1593");
call mtr.add_suppression("Mismatch between the number of bytes configured to store checkpoint information and the previously stored information");

set @save.replica_checkpoint_group= @@global.replica_checkpoint_group;
set @save.replica_parallel_workers= @@global.replica_parallel_workers;
SET @@global.replica_parallel_workers= 2;
SET @@global.replica_checkpoint_group=524281;

## TEST #1 

# check that replica will start with the replica_checkpoint_group
# if include/start_replica.inc does not timeout then the replica was able to start correctly
--source include/start_replica.inc

--let $assert_cond= @@replica_checkpoint_group=524280
--let $assert_text= Assert that replica_checkpoint_group was truncated to a valid value.
--source include/assert.inc

--source include/check_replica_is_running.inc

--source include/rpl_reset.inc

## TEST #2
#
# Check that even if the initialization of the info storage
# fails the server won't crash.

--source include/stop_replica.inc
--let $saved_debug=`SELECT @global.debug`
SET @@global.debug= "d,inject_init_worker_init_info_fault";
START REPLICA SQL_THREAD;
--let $replica_sql_errno=1593
--source include/wait_for_replica_sql_error.inc
SET @@global.debug= @save.debug;

# cleanup

set @@global.replica_checkpoint_group= @save.replica_checkpoint_group;
set @@global.replica_parallel_workers= @save.replica_parallel_workers;

#
# BUG13893310 Checkpoint_group
#
# testing various error branches with simulating errors:
#

## Rpl_info_factory::reset_workers() error branch

call mtr.add_suppression("Could not delete from Replica Workers info repository.");
# restart replica with workers
--source include/stop_replica.inc
set @save.replica_parallel_workers= @@global.replica_parallel_workers;
set @@global.replica_parallel_workers= 2;
--source include/start_replica.inc
--source include/stop_replica.inc

set @@global.debug= "d,mts_debug_reset_workers_fails";

let $relay_file = query_get_value( SHOW REPLICA STATUS, Relay_Log_File, 1 );
let $relay_pos = query_get_value( SHOW REPLICA STATUS, Relay_Log_Pos, 1 );
--replace_regex /relay_log_file=[^,]+/RELAY_LOG_FILE=FILE/ /relay_log_pos=[0-9]+/ RELAY_LOG_POS= POS/
--error ER_MTS_RESET_WORKERS
eval change primary to relay_log_file='$relay_file', relay_log_pos=$relay_pos;

## Relay_log_info::reset_workers_recovered() error branch

set @@global.debug= "d,mts_debug_recovery_reset_fails";
start replica sql_thread;
# ER_REPLICA_FATAL_ERROR
--let $replica_sql_errno=1593
--source include/wait_for_replica_sql_error.inc

#
# mts_recovery_groups() error branche
#

set @@global.debug= @save.debug;

set @@global.replica_parallel_workers= 2;
--source include/start_replica.inc
--source include/stop_replica.inc

call mtr.add_suppression("Error creating relay log info: Failed to initialize the worker info structure.");

set @@global.debug= "d,mts_replica_worker_init_at_gaps_fails";
--error ER_PRIMARY_INFO
start replica sql_thread;

#
# clean up
#
SET @@global.debug= "";
set @@global.replica_parallel_workers= @save.replica_parallel_workers;

--source include/start_replica.inc
--source include/rpl_reset.inc

--source include/rpl_end.inc
