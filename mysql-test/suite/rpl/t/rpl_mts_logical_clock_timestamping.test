#
# The test verifies execution specially timestamped transactions and
# erroring out due to inconsistent timestamps found.
#
--source include/have_debug.inc
--source include/primary-replica.inc
# format - non-specific test is enough to executed in MIXED mode only.
--source include/have_binlog_format_mixed.inc

--connection replica
call mtr.add_suppression("Transaction is tagged with inconsistent logical timestamps");
call mtr.add_suppression("Cannot execute the current event group in the parallel mode.");
#call mtr.add_suppression("Replica I/O: Got fatal error 1236 from primary when reading data from binary log");

--source include/stop_replica.inc

SET @save_replica_parallel_type = @@GLOBAL.replica_parallel_type;
SET @save_replica_parallel_workers = @@GLOBAL.replica_parallel_workers;
SET @save_replica_transaction_retries = @@GLOBAL.replica_transaction_retries;

SET GLOBAL replica_parallel_type = LOGICAL_CLOCK;
SET GLOBAL replica_parallel_workers = 3;
SET GLOBAL replica_transaction_retries = 0;

#
# Part I. "Rotated" transactions apply correctly.
# At times Primary generalates last_committed as magic SEQ_UNINIT which
# designates the transaction's commit parent is unknown so
# it has to be applied in exclusive environment, aka
# fallback to sequential mode.
#

# Create a chain of binlogs containing two consequent SEQ_UNINIT last_committed
# transactions in one them.

connect (primary2,localhost,root,,);

--connection primary
--let $MYSQLD_DATADIR= `select @@datadir`
--let $events_file=$MYSQLTEST_VARDIR/tmp/events.sql

RESET PRIMARY; # make sure we start from 0000001 binlog

CREATE TABLE t1 (a int) ENGINE= innodb;
INSERT INTO t1 SET a=1;

--connection primary1
BEGIN;
INSERT INTO t1 SET a=2;

--connection primary2
BEGIN;
INSERT INTO t1 SET a=3;

--connection primary
FLUSH LOGS;

--connection primary1
COMMIT;
--connection primary2
COMMIT;

# two timestamp pair of (0,[12]) must be found.
--exec $MYSQL_BINLOG --force-if-open $MYSQLD_DATADIR/primary-bin.000002 > $events_file
--let $grep_file= $events_file
--let $grep_pattern= last_committed=0\tsequence_number=[12]
--let $grep_output= print_count
--source include/grep_pattern.inc

# Create a chain of binlogs containing two consequent SEQ_UNINIT last_committed
# transactions separated by a Rotate event.

--connection primary
INSERT INTO t1 SET a=1;

--connection primary1
BEGIN;
INSERT INTO t1 SET a=2;

--connection primary2
BEGIN;
INSERT INTO t1 SET a=3;

--connection primary
FLUSH LOGS;

--connection primary1
COMMIT;

--connection primary
FLUSH LOGS;

--connection primary2
COMMIT;

--connection primary
--send INSERT INTO t1 SET a=1
--connection primary1
--send INSERT INTO t1 SET a=2
--connection primary2
--send INSERT INTO t1 SET a=3

--connection primary
--reap
--connection primary1
--reap
--connection primary2
--reap


--connection replica
--source include/start_replica.inc

# Proof of correctess stable execution
--connection primary
--sync_replica_with_primary

--let $diff_tables=primary:t1,replica:t1
--source include/diff_tables.inc

#
# Part II. Let's feign inconsistent timestamping
# to see how Replica expectedly stops.
#

--connection primary
SET @@session.debug ='+d,feign_commit_parent';
INSERT INTO t1 SET a=0;
SET @@session.debug ='-d,feign_commit_parent';

--connection replica
--let $replica_sql_errno= convert_error(ER_MTS_CANT_PARALLEL)
--source include/wait_for_replica_sql_to_stop.inc
--source include/stop_replica_io.inc


# "Manual" recovery to restart anew 'cos of the schrambled event
--connection primary
RESET PRIMARY;

--connection replica
RESET REPLICA;
RESET PRIMARY;
--source include/start_replica.inc

#
# Cleanup
#
--connection primary
DROP TABLE t1;

--sync_replica_with_primary

#--connection replica
--source include/stop_replica.inc
SET @@GLOBAL.replica_parallel_type= @save_replica_parallel_type;
SET @@GLOBAL.replica_parallel_workers= @save_replica_parallel_workers;
SET @@GLOBAL.replica_transaction_retries= @save_replica_transaction_retries;
--source include/start_replica.inc

--source include/rpl_end.inc

