#
# WL#5569/7165 MTS
#
# The test checks START and STOP, graceful, killing or
# due to an error of a Worker.
# START is considered to be with UNTIL that forces the sequential execution mode
# and with non-zero @@global.sql_replica_skip_counter that is compatible to
# the parallel mode.
# The test is MTS scheduler agnostic.
#

--source include/have_binlog_format_row.inc
--source include/not_gtid_enabled.inc
--source include/have_myisam.inc
--source include/primary-replica.inc

--connection replica

call mtr.add_suppression("Replica SQL for channel '':.* Could not execute Write_rows event on table test.t1");
call mtr.add_suppression("Replica SQL for channel '':.* Could not execute Update_rows event on table d1.t1; Deadlock found when trying to get lock");
call mtr.add_suppression("The replica coordinator and worker threads are stopped, possibly leaving data in inconsistent state");

create view worker_proc_list as SELECT id  from Information_Schema.processlist
       where state like 'Waiting for an event from Coordinator';
create view coord_proc_list  as SELECT id from Information_Schema.processlist where state like 'Replica has read all relay log%';

source include/stop_replica.inc;

set @save.replica_parallel_workers= @@global.replica_parallel_workers;
set @@global.replica_parallel_workers= 4;

source include/start_replica.inc;

let $count= `select @@global.replica_parallel_workers`;
let $table= worker_proc_list;
source include/wait_until_rows_count.inc;

#
# KILL of a Worker stops the pool and the Coordinator
#
select min(id) from worker_proc_list into @w_id;
kill query @w_id;

let $count= 0;
let $table= worker_proc_list;
source include/wait_until_rows_count.inc;

source include/wait_for_replica_sql_to_stop.inc;

#
# KILL of the Coordinator stops the pool as well
#
source include/start_replica.inc;

# testing of the poll is up

let $count= `select @@global.replica_parallel_workers`;
let $table= worker_proc_list;
source include/wait_until_rows_count.inc;

let $count= 1;
let $table= coord_proc_list;
source include/wait_until_rows_count.inc;

select id from coord_proc_list into @c_id;

kill query @c_id;

let $count= 0;
let $table= worker_proc_list;
source include/wait_until_rows_count.inc;

let $replica_sql_errno= 1756; # ER_MTS_PARALLEL_INCONSISTENT_DATA
source include/wait_for_replica_sql_error.inc;

source include/start_replica.inc;

##
# Errored-out Worker stops the pool and the Coordinator
##

#
# A. A regular error case
#
--connection primary

# make some load

CREATE TABLE t1 (a int primary key) engine=innodb;

insert into t1 values (1),(2);

--source include/sync_replica_sql_with_primary.inc
#connection replica;

let $count= 2;
let $table= t1;
source include/wait_until_rows_count.inc;

# create an offending record
insert into t1 values (3);

--connection primary

# hit it
insert into t1 values (3);

--connection replica

let $count= 0;
let $table= worker_proc_list;
source include/wait_until_rows_count.inc;

source include/wait_for_replica_sql_to_stop.inc;
delete from t1 where a=3;

set @save.replica_transaction_retries= @@global.replica_transaction_retries;
set @@global.replica_transaction_retries= 10;
source include/start_replica.inc;

--connection primary

--source include/sync_replica_sql_with_primary.inc
#connection replica;

if (`select count(*) != 3 from t1`)
{
    query_vertical show replica status;
    --die Wrong recovery after restart
}

# cleanup but leaving on t1

--connection primary
delete from t1;

--source include/sync_replica_sql_with_primary.inc
#connection replica;

#
# B. In a temporary error execution is retried
#

--connection primary
insert into t1 values (1),(2),(3);
create table t2m (a int) engine=myisam; # non-trans engine to detect deadlock
insert into t2m values (1);

--source include/sync_replica_sql_with_primary.inc
#connection replica;

begin;
# set up a deadlock
update t1 set a=31 where a=3;
insert into t1 values (5),(6),(7);
update t1 set a=a+10;

--connection primary

begin;
update t1 set a=20 where a=2;
insert into t2m values (2);
update t1 set a=30 where a=3;
commit;


--connection replica

let $count= 2;
let $table= t2m;
source include/wait_until_rows_count.inc;

# must victimize the primary trans because of deadlock or timeout
update t1 set a=21 where a=2;

rollback;

--connection primary

# recovery is proved
#--connection replica
--source include/sync_replica_sql_with_primary.inc

#
# Skipping works with Parallel replica
#

--connection replica
stop replica sql_thread;
set @@global.sql_replica_skip_counter=7;

--connection primary

# the following creates 8 events
begin;
select max(a) + 1 from t1 into @a;
insert into t1 set a=@a;
commit;
begin;
select max(a) + 1 from t1 into @a;
insert into t1 set a=@a;
commit;

# which will force to skip the two above transactions by the replica
# And the third will be executed:

begin;
select max(a) + 1 from t1 into @a;
insert into t1 set a=@a;
commit;

--connection replica

start replica sql_thread;

--connection primary
let $a=`select max(a) from t1`;

--source include/sync_replica_sql_with_primary.inc
#connection replica;

if (`select $a - max(a) from t1`)
{
    eval select $a as 'max(a) from t1 on primary';
    eval select max(a) as 'max(a) from t1 on replica' from t1;
    --die Wrong skipping logics or a flaw in the test
}

#
# UNTIL condition other than SQL_AFTER_MTS_GAPS
# is not supported by Parallel replica to reject
# with a warning and no Worker thread is started
#

--connection replica
source include/stop_replica.inc;

--connection primary
create table t2 (a int);

let $primary_log_file= query_get_value(SHOW PRIMARY STATUS, File, 1);
let $primary_log_pos= query_get_value(SHOW PRIMARY STATUS, Position, 1);

insert into t2 values (1);

--connection replica
--replace_regex /primary_log_pos=[0-9]+/primary_log_pos=PRIMARY_LOG_POS/
eval start replica until primary_log_file='$primary_log_file', primary_log_pos=$primary_log_pos;

source include/wait_for_replica_sql_to_stop.inc;
if (`select count(*) from t2`)
{
    select count(*) from t2;
    --die Wrong UNTIL condtion handling or a flaw in the test
}

source include/start_replica.inc;

##
# cleanup
##
--connection primary
drop table t1;
drop table t2m;
drop table t2;

--source include/sync_replica_sql_with_primary.inc
drop view worker_proc_list;
drop view coord_proc_list;

#
# START REPLICA UNTIL SQL_AFTER_MTS_GAPS
#
# A new UNTIL condition is introduced as a tool to
# fill gaps in the sequence of executed transaction started
# at Exec_Primary_Log_Pos.
# The gaps could be caused by the previous replica session stop
# with an error, or it was killed, or the server crashed.
#

--connection replica

#
# Retry is supported now, but the following block of the test is written
# in assumption that it's not yet.
#
set @@global.replica_transaction_retries= 0;
source include/stop_replica.inc;

# Show SQL_AFTER_MTS_GAPS is meaningless in combination with coordinates
# related options
--error 1064
start replica until sql_after_mts_gaps relay_log_file='dummy';
--error 1064
start replica until sql_after_mts_gaps relay_log_pos=0;
--error 1064
start replica until sql_after_mts_gaps primary_log_file='dummy';
--error 1064
start replica until sql_after_mts_gaps primary_log_pos=0;
--error 1064
start replica until sql_after_mts_gaps SQL_BEFORE_GTIDS='dummy';

call mtr.add_suppression('Replica SQL for channel '': Could not execute Update_rows event on table d1.t1; Deadlock found when trying to get lock');

# regular start now
source include/start_replica.inc;

# set up gaps when replica sql errors out
--connection primary

create database d1;
create database d2;
create table d1.t1 (a int primary key) engine=innodb;
create table d2.t1 (a int primary key) engine=innodb;
create table d1.t2m (a int) engine=myisam; # non-trans engine to detect deadlock
insert into d1.t1 values (1),(2),(3);
insert into d2.t1 values (1),(2),(3);
insert into d1.t2m values (1);

--source include/sync_replica_sql_with_primary.inc
#connection replica;
begin; # the blocker
# set up a deadlock at the 1st job
update d1.t1 set a=31 where a=3;
insert into d1.t1 values (5),(6),(7);

# create the 1st job to get blocked on the replica
--connection primary
begin;
update d1.t1 set a=20 where a=2;
insert into d1.t2m values (2);
update d1.t1 set a=30 where a=3;
insert into d1.t1 values (4);

# create the 2nd job for another worker
--connection primary1
begin;
delete from d2.t1;

# the two jobs are parallelizable now regardless of the type of MTS scheduler
--connection primary
commit;
--connection primary1
commit;

--connection primary
# create the 3nd job to help UNTIL SQL_AFTER_MTS_GAPS be reached
# (todo: if the last gap event ends the relay-log SQL thread will
# hang - to be fixed with MTS support for regular UNTIL:s)
delete from d1.t1;

# wait till the 2nd job will be done
connection replica1;
let $count= 0;
let $table= d2.t1;
source include/wait_until_rows_count.inc;

# proceed with 1st job into its middle
--connection replica
let $count= 2;
let $table= d1.t2m;
source include/wait_until_rows_count.inc;

# must victimize the primary trans because of deadlock or timeout
update d1.t1 set a=21 where a=2;

# replica is stopped
# setting timeout to be as twice as greater than innodb's.
--let $replica_timeout=`select 2*@@global.innodb_lock_wait_timeout`

let $replica_sql_errno= 1213, 1205;
source include/wait_for_replica_sql_error.inc;

rollback; # the blocker

# find out Exec_Primary_Log_Pos to store it in Exec_0
let $exec_pos_0= query_get_value(SHOW REPLICA STATUS, Exec_Primary_Log_Pos, 1);

start replica until sql_after_mts_gaps;

# Efficiency of UNTIL proof:
source include/wait_for_replica_sql_to_stop.inc;

# Consistency proof:

if (`select count(*) <> 4 from d1.t1`)
{
    --echo *** Something is wrong in recovery ***
    --die
}

# Efficiency of gap filling proof:
# find out Exec_Primary_Log_Pos and compare with Exec_0
let $exec_pos_1= query_get_value(SHOW REPLICA STATUS, Exec_Primary_Log_Pos, 1);

if (`select $exec_pos_1 - $exec_pos_0 <= 0`)
{
    --echo *** No gap transaction is executed as expected ***
    --connection replica
    show replica status;
    --connection primary
    show primary status;
    --die
}

# UNTIL SQL_AFTER_MTS_GAPS cleanup
set @@global.replica_parallel_workers= @save.replica_parallel_workers;
source include/start_replica.inc;
--connection primary
drop database d1;
drop database d2;

--source include/sync_replica_sql_with_primary.inc
set @@global.replica_transaction_retries= @save.replica_transaction_retries;

--source include/rpl_end.inc
