#
#  Description
#  ===========
#
#  This test case checks whether binlog files contain Before and After
#  image values as expected. Configuration is done using the
#  --binlog-row-image variable.
#
#  How it works
#  ============
#
#  The test case is implemented such that primary and replica basically
#  hold the same table but sometimes differ in indexes, number of
#  columns and data types constraints (autoinc or NOT NULL). Then some
#  statements are executed and the output of mysqlbinlog is parsed for
#  the given event to check if the columns in the before and after
#  image match expectations according to the binlog-row-image value on
#  primary and on replica.
#
#  See also WL#5096.
#
--source include/not_group_replication_plugin.inc
-- source include/have_binlog_format_row.inc
-- source include/no_valgrind_without_big.inc
-- source include/primary-replica.inc

-- connection replica
call mtr.add_suppression("Replica: Can\'t find record in \'t\' Error_code: 1032");
call mtr.add_suppression("Replica SQL for channel '': .*Could not execute Update_rows event on table test.t; Can.t find record in .t.* Error_code: 1032");
call mtr.add_suppression("The replica coordinator and worker threads are stopped, possibly leaving data in inconsistent state");

-- connection primary

## assertion: check that default value for binlog-row-image == 'FULL'
SHOW VARIABLES LIKE 'binlog_row_image';

## save original 
-- connection primary
SET @old_binlog_row_image= @@binlog_row_image;
-- connection replica
SET @old_binlog_row_image= @@binlog_row_image;
-- connection primary

-- echo #####################################################
-- echo # basic assertion that binlog_row_image='FULL' is the
-- echo # default 
-- echo #####################################################

-- connection primary
-- let $row_img_set=primary:FULL:N,replica:FULL:Y
-- source include/rpl_row_img_set.inc

CREATE TABLE t (c1 int, c2 int, c3 blob, primary key(c1));

-- let $row_img_query= INSERT INTO t(c1,c3) VALUES (1, 'a')
-- let $row_img_expected_primary= | 1:1 2:NULL 3:'a'
-- let $row_img_expected_replica = | 1:1 2:NULL 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c1=2 WHERE c1=1;
-- let $row_img_expected_primary= 1:1 2:NULL 3:'a' | 1:2 2:NULL 3:'a'
-- let $row_img_expected_replica = 1:1 2:NULL 3:'a' | 1:2 2:NULL 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= DELETE FROM t;
-- let $row_img_expected_primary= 1:2 2:NULL 3:'a' |
-- let $row_img_expected_replica = 1:2 2:NULL 3:'a' |
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

#
# Assertions: combines img_types with different index types. 
#             The checks that rows are logged with expected
#             image contents, depending on the img_type.
#

-- connection primary
SET @img_types= 'MINIMAL NOBLOB FULL';
while (`SELECT HEX(@img_types) != HEX('')`)
{
  -- disable_query_log
  let $img_type= `SELECT SUBSTRING_INDEX(@img_types, ' ', 1)`;
  -- let $row_img_set=primary:$img_type:N,replica:$img_type:Y
  -- source include/rpl_row_img_set.inc

  SET @index_types= 'UK-NOT-NULL PK UK K NONE';
  while (`SELECT HEX(@index_types) != HEX('')`)
  {
    -- disable_query_log
    let $index_type= `SELECT SUBSTRING_INDEX(@index_types, ' ', 1)`;
    -- enable_query_log

    -- echo ITERATIONS: row_img: $img_type, indexes: $index_type

    -- source include/rpl_reset.inc
    -- connection primary

    # create the table
    -- echo CREATING TABLE IN $CURRENT_CONNECTION WITH INDEX '$index_type'

    if (`SELECT HEX('$index_type') = HEX('NONE')`)
    {
      CREATE TABLE t (c1 int, c2 int, c3 blob);
    }

    if (`SELECT HEX('$index_type') = HEX('K')`)
    {
      CREATE TABLE t (c1 int, c2 int, c3 blob, key(c1));
    }

    if (`SELECT HEX('$index_type') = HEX('UK')`)
    {
      CREATE TABLE t (c1 int, c2 int, c3 blob, unique key(c1));
    }

    if (`SELECT HEX('$index_type') = HEX('PK')`)
    {
      CREATE TABLE t (c1 int, c2 int, c3 blob, primary key(c1));
    }

    if (`SELECT HEX('$index_type') = HEX('UK-NOT-NULL')`)
    {
      CREATE TABLE t (c1 int NOT NULL, c2 int, c3 blob, unique key(c1));
    }

    --source include/sync_replica_sql_with_primary.inc
    -- connection primary

    # Issue some statements

    -- let $row_img_query= INSERT INTO t VALUES (1,2,"a")
    -- let $row_img_expected_primary= | 1:1 2:2 3:'a'
    -- let $row_img_expected_replica = | 1:1 2:2 3:'a'
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= INSERT INTO t(c1,c3) VALUES (10,"a")
    if (`SELECT @@binlog_row_image = "FULL" or @@binlog_row_image = "NOBLOB"`)
    {
      -- let $row_img_expected_primary= | 1:10 2:NULL 3:'a'
    }
    if  (`SELECT @@binlog_row_image = "MINIMAL"`)
    {
      -- let $row_img_expected_primary= | 1:10 3:'a'
    }
    -- let $row_img_expected_replica= $row_img_expected_primary
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= INSERT INTO t(c1) VALUES (1000)
    if (`SELECT @@binlog_row_image = "FULL"`)
    {
      -- let $row_img_expected_primary= | 1:1000 2:NULL 3:NULL
    } 
    if  (`SELECT @@binlog_row_image = "NOBLOB"`)
    { 
      -- let $row_img_expected_primary= | 1:1000 2:NULL
    }
    if  (`SELECT @@binlog_row_image = "MINIMAL"`)
    { 
      -- let $row_img_expected_primary= | 1:1000
    }
    -- let $row_img_expected_replica= $row_img_expected_primary
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= UPDATE t SET c1=2 WHERE c1=1
    if (`SELECT @@binlog_row_image = "FULL" OR (SELECT '$index_type' IN ('NONE', 'K', 'UK'))`)
    {
      -- let $bi= 1:1 2:2 3:'a'
    }

    # noblob with pk + uk not nullable
    if (`SELECT @@binlog_row_image = "NOBLOB" AND (SELECT '$index_type' IN ('PK', 'UK-NOT-NULL'))`)
    {
      -- let $bi= 1:1 2:2
    }

    if (`SELECT @@binlog_row_image = "MINIMAL" AND (SELECT '$index_type' IN ('PK', 'UK-NOT-NULL'))`)
    {
      -- let $bi= 1:1
    }

    if (`SELECT @@binlog_row_image = "FULL"`)
    {
      -- let $ai= 1:2 2:2 3:'a'
    }

    if (`SELECT @@binlog_row_image = "NOBLOB"`)
    {
      -- let $ai= 1:2 2:2
    }

    if (`SELECT @@binlog_row_image = "MINIMAL"`)
    {
      -- let $ai= 1:2
    }
    -- let $row_img_expected_primary= $bi | $ai
    -- let $row_img_expected_replica = $bi | $ai
    -- let $ai=
    -- let $bi=
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= DELETE FROM t WHERE c2=2
    # no key, simple key or unique key nullable
    if (`SELECT @@binlog_row_image = "FULL" OR (SELECT '$index_type' IN ('NONE', 'K', 'UK'))`)
    {
      -- let $row_img_expected_primary= 1:2 2:2 3:'a' |
    }

    # noblob with pk + uk not nullable
    if (`SELECT @@binlog_row_image = "NOBLOB" AND (SELECT '$index_type' IN ('PK', 'UK-NOT-NULL'))`)
    {
      -- let $row_img_expected_primary= 1:2 2:2 |
    }

    if (`SELECT @@binlog_row_image = "MINIMAL" AND (SELECT '$index_type' IN ('PK', 'UK-NOT-NULL'))`)
    {
      -- let $row_img_expected_primary= 1:2 |
    }
    -- let $row_img_expected_replica= $row_img_expected_primary
    -- source include/rpl_row_img_parts_primary_replica.inc

    DROP TABLE t;

    --source include/sync_replica_sql_with_primary.inc

    -- disable_query_log
    -- connection primary
    -- eval SET @index_types= LTRIM(SUBSTRING(@index_types, LENGTH('$index_type') + 1))
    -- enable_query_log

  }

  -- disable_query_log
  -- connection primary
  -- eval SET @img_types= LTRIM(SUBSTRING(@img_types, LENGTH('$img_type') + 1))
  -- enable_query_log
}

### Some more scenarios
###  These relate to different constraints on PKE and its impact 
###  on logged images. Further description is inline.

-- connection primary
SET @img_types= 'MINIMAL NOBLOB FULL';
while (`SELECT HEX(@img_types) != HEX('')`)
{
  -- disable_query_log
  let $img_type= `SELECT SUBSTRING_INDEX(@img_types, ' ', 1)`;
  -- let $row_img_set=primary:$img_type:N,replica:$img_type:Y
  -- source include/rpl_row_img_set.inc

  -- echo ITERATIONS: row_img: $img_type

  -- source include/rpl_reset.inc
  -- connection primary

  # ASSERTIONS:
  # UPDATE (MINIMAL,NOBLOB,FULL)
  #  - on replica, columns that are not in primary's BI but are in replica's
  #    PKE are in replica's BI

  -- connection primary
  SET SQL_LOG_BIN=0;
  CREATE TABLE t (a INT);
  SET SQL_LOG_BIN=1;

  -- connection replica
  SET SQL_LOG_BIN=0;
  CREATE TABLE t (a INT, b INT DEFAULT 1000);
  SET SQL_LOG_BIN=1;

  -- connection primary
  INSERT INTO t VALUES (1);
  --source include/sync_replica_sql_with_primary.inc
  -- connection primary

  -- let $row_img_query= UPDATE t SET a=2 WHERE a=1;
  #   1. columns that are set to default value are in AI
  -- let $row_img_expected_primary= 1:1 | 1:2
  if (`SELECT @@binlog_row_image = "NOBLOB" OR (SELECT @@binlog_row_image = "FULL")`)
  {
    -- let $row_img_expected_replica = 1:1 2:1000 | 1:2 2:1000
  }
  if (`SELECT @@binlog_row_image = "MINIMAL"`)
  {
    -- let $row_img_expected_replica = 1:1 2:1000 | 1:2
  }
  -- source include/rpl_row_img_parts_primary_replica.inc

  -- connection primary
  DROP TABLE IF EXISTS t;
  --source include/sync_replica_sql_with_primary.inc

  -- source include/rpl_reset.inc

  -- connection primary
  if (`SELECT @@binlog_row_image = "MINIMAL"`)
  {
    -- echo ####### MINIMAL PARTICULAR SCENARIO ######
  
    # ASSERTIONS: 
    #   INSERT/MINIMAL
    #      1. columns that are set to default value are in AI
    #
    #    UPDATE/MINIMAL:
    #      2. columns that are set to the same value are in AI
    #      3. columns that are not in WHERE clause but in PKE are in BI
    #      4. on replica, columns that are not in primary's BI but are in replica's
    #         PKE are in replica's BI
    #    
    #    DELETE/MINIMAL:
    #      5. on replica, columns that are in primary's BI but not in replica's PKE are
    #         not in replica's BI
    #      6. columns that are NOT NULL UK but not in PK are not in BI
    #
    -- connection primary
    SET SQL_LOG_BIN=0;
    CREATE TABLE t (c1 INT PRIMARY KEY, c2 INT DEFAULT 100, c3 INT);
    SET SQL_LOG_BIN=1;

    -- connection replica
    SET SQL_LOG_BIN=0;
    CREATE TABLE t (c1 INT NOT NULL UNIQUE KEY, c2 INT DEFAULT 100, c3 INT, c4 INT, PRIMARY KEY(c2,c3));

    -- let $row_img_query= INSERT INTO t VALUES (1, 100, 1);
    #   1. columns that are set to default value are in AI
    -- let $row_img_expected_primary= | 1:1 2:100 3:1
    -- let $row_img_expected_replica = | 1:1 2:100 3:1
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= UPDATE t SET c2=100, c3=1000 WHERE c2=100;
    #   2. columns that are set to the same value are in AI
    #   3. columns that are not in WHERE clause but in PKE are in BI
    #   4. on replica, columns that are not in primary's BI but are in replica's PKE are in replica's BI
    -- let $row_img_expected_primary= 1:1 | 2:100 3:1000
    -- let $row_img_expected_replica = 2:100 3:1 | 2:100 3:1000
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- let $row_img_query= DELETE FROM t WHERE c1=1
    # asserts:
    #   5. on replica, columns that are not in primary's BI but are in replica's PKE are in replica's BI
    #   6. columns that are NOT NULL UK but not in PK are not in BI
    -- let $row_img_expected_primary= 1:1 |
    -- let $row_img_expected_replica= 2:100 3:1000 | 
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- connection primary
    DROP TABLE t;
    --source include/sync_replica_sql_with_primary.inc

    -- echo ####### MINIMAL OTHER PARTICULAR SCENARIO ######
  
    # ASSERTIONS: 
    #    UPDATE/MINIMAL:
    #      1. all columns needed to identify a row are in BI; as the
    #      index is not unique, this means all columns of the table
    #      2. columns that are in SET changed are in AI
    #      3. columns that are not in SET are not in AI
    #      4. table on replica has the same definition as table on
    #      primary, so points 1-2-3 apply to images in the replica's
    #      binlog too.
    #
    -- connection primary
    CREATE TABLE t (c1 INT NOT NULL, c2 INT NOT NULL, KEY (c1));
    INSERT INTO t VALUES (30,40);

    -- connection replica

    -- let $row_img_query= UPDATE t SET c2=100 ORDER BY c1;
    #   1. all columns needed to identify a row are in BI
    #   2. columns that are in SET changed are in AI
    #   3. columns that are not in SET are not in AI
    #   4. replica is as primary as tables' definitions are identical
    -- let $row_img_expected_primary= 1:30 2:40 | 2:100
    -- let $row_img_expected_replica = 1:30 2:40 | 2:100
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- connection primary
    DROP TABLE t;
    --source include/sync_replica_sql_with_primary.inc
  }

  if (`SELECT @@binlog_row_image = "NOBLOB"`)
  {
    -- echo ####### NOBLOB PARTICULAR SCENARIO ######

    #    ASSERTIONS: 
    #    INSERT/NOBLOB:
    #      1 non-blob columns that are set to default value are in AI
    #    
    #    UPDATE/NOBLOB:
    #      2 non-blob columns that are set to default value are in AI
    #      3 blob columns that are set to default value are in AI
    #      4 blob columns that are in WHERE clause but not in PKE are not in BI
    #      5 blob columns that are in NON-NULL UK but not in PK are not in BI
    #      6 on replica, blob columns that are in primary's BI clause but not in
    #        replica's PKE are not in BI
    #
    #    DELETE
    #      7 non-blob columns that are not in WHERE clause but in PKE are in BI
    #      8 blob columns that are used in WHERE clause but not in PKE are not
    #        in BI
    #      9 blob columns that are NOT NULL UK but not in PK are not in BI
    #     10 on replica, blob columns that are in primary's BI but not in replica's PKE
    #        are not in replica's BI

    -- connection primary
    SET SQL_LOG_BIN=0;
    CREATE TABLE t (c1 INT, c2 BLOB, c3 INT DEFAULT 1000, c4 BLOB NOT NULL, c5 INT, UNIQUE KEY(c4(512)), PRIMARY KEy(c1, c2(512)));
    SET SQL_LOG_BIN=1;

    -- connection replica
    SET SQL_LOG_BIN=0;
    CREATE TABLE t (c1 INT PRIMARY KEY, c2 BLOB, c3 INT DEFAULT 1000, c4 BLOB, c5 INT);
    SET SQL_LOG_BIN=1;

    -- connection primary
    -- let $row_img_query= INSERT INTO t VALUES (1,'aaa', 1000, 'bbb', 1)
    #   1. non-blob columns that are set to default value are in AI
    -- let $row_img_expected_primary= | 1:1 2:'aaa' 3:1000 4:'bbb' 5:1
    -- let $row_img_expected_replica = | 1:1 2:'aaa' 3:1000 4:'bbb' 5:1
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- connection primary
    -- let $row_img_query= UPDATE t SET c2='aaa', c3=1000, c5=10000 WHERE c1=1 AND c4='bbb'
    # asserts that:
    #  2. non-blob columns that are set to default value are in AI
    #  3. blob columns that are set to default value are in AI
    #  4. blob columns that are in WHERE clause but not in PKE are not in BI
    #  5. blob columns that are in NON-NULL UK but not in PK are not in BI
    #  6. on replica, blob columns that are in primary's BI clause but not in
    #     replica's PKE are not in BI
    -- let $row_img_expected_primary= 1:1 2:'aaa' 3:1000 5:1 | 1:1 2:'aaa' 3:1000 5:10000
    -- let $row_img_expected_replica = 1:1 3:1000 5:1 | 1:1 2:'aaa' 3:1000 5:10000
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- connection primary
    -- let $row_img_query= DELETE FROM t WHERE c1=1 AND c4='bbb'
    # asserts that:
    #   7. non-blob columns that are not in WHERE clause but in PKE are in BI
    #   8. blob columns that are used in WHERE clause but not in PKE are not n BI
    #   9. blob columns that are NOT NULL UK but not in PK are not in BI
    #  10. on replica, blob columns that are in primary's BI but not in replica's PKE are not in replica's BI
    -- let $row_img_expected_primary= 1:1 2:'aaa' 3:1000 5:10000 | 
    -- let $row_img_expected_replica = 1:1 3:1000 5:10000 | 
    -- source include/rpl_row_img_parts_primary_replica.inc

    -- connection primary
    DROP TABLE t;
    --source include/sync_replica_sql_with_primary.inc

  }

  -- disable_query_log
  -- connection primary
  -- eval SET @img_types= LTRIM(SUBSTRING(@img_types, LENGTH('$img_type') + 1))
  -- enable_query_log
}

-- echo ################## SPECIAL CASES #########################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:NOBLOB:N,replica:NOBLOB:Y
-- source include/rpl_row_img_set.inc

-- echo ###################################
-- echo # PK (contains blob)
-- echo ###################################

-- connection primary

CREATE TABLE t (c1 int, c2 int, c3 blob, primary key(c1,c3(512)));

-- let $row_img_query= INSERT INTO t VALUES (1,2,"a")
-- let $row_img_expected_primary= | 1:1 2:2 3:'a'
-- let $row_img_expected_replica = | 1:1 2:2 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= INSERT INTO t(c1,c3) VALUES (10,"a")
-- let $row_img_expected_primary= | 1:10 2:NULL 3:'a'
-- let $row_img_expected_replica = | 1:10 2:NULL 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= INSERT INTO t(c1) VALUES (1000)
-- let $row_img_expected_primary= | 1:1000 2:NULL
-- let $row_img_expected_replica = | 1:1000 2:NULL
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c1=2 WHERE c1=1
-- let $row_img_expected_primary= 1:1 2:2 3:'a' | 1:2 2:2
-- let $row_img_expected_replica = 1:1 2:2 3:'a' | 1:2 2:2
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= DELETE FROM t WHERE c2=2
-- let $row_img_expected_primary= 1:2 2:2 3:'a' | 
-- let $row_img_expected_replica = 1:2 2:2 3:'a' | 
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;

--source include/sync_replica_sql_with_primary.inc

-- echo ###################################
-- echo # PK (does not contain blob, but blob is updated)
-- echo ###################################

-- source include/rpl_reset.inc
-- connection primary

CREATE TABLE t (c1 int, c2 int, c3 blob, primary key(c1,c2));

-- let $row_img_query= INSERT INTO t VALUES (1,2,"a")
-- let $row_img_expected_primary= | 1:1 2:2 3:'a'
-- let $row_img_expected_replica = | 1:1 2:2 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= INSERT INTO t(c1,c3) VALUES (10,"a")
-- let $row_img_expected_primary= | 1:10 2:0 3:'a'
-- let $row_img_expected_replica = | 1:10 2:0 3:'a'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= INSERT INTO t(c1) VALUES (1000)
-- let $row_img_expected_primary= | 1:1000 2:0
-- let $row_img_expected_replica = | 1:1000 2:0
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c3='b' WHERE c1=1
-- let $row_img_expected_primary= 1:1 2:2 | 1:1 2:2 3:'b'
-- let $row_img_expected_replica = 1:1 2:2 | 1:1 2:2 3:'b'
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= DELETE FROM t WHERE c2=2
-- let $row_img_expected_primary= 1:1 2:2 | 
-- let $row_img_expected_replica = 1:1 2:2 | 
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ###################################
-- echo # AUTOINC columns
-- echo ###################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:MINIMAL:Y
-- source include/rpl_row_img_set.inc

CREATE TABLE t (c1 int NOT NULL AUTO_INCREMENT, c2 int, c3 blob, primary key(c1,c2));

-- let $row_img_query= INSERT INTO t(c2) VALUES (2)
-- let $row_img_expected_primary= | 1:1 2:2
-- let $row_img_expected_replica = | 1:1 2:2
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ##################################################################
-- echo # Test that replica does not write more columns than the ones it has 
-- echo ##################################################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:MINIMAL:Y
-- source include/rpl_row_img_set.inc

SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int NOT NULL AUTO_INCREMENT, c2 int, c3 blob, primary key(c1,c2));
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int, c2 int, primary key(c1));

-- connection primary

-- let $row_img_query= INSERT INTO t(c2,c3) VALUES (2,'aaaaa')
-- let $row_img_expected_primary= | 1:1 2:2 3:'aaaaa'
-- let $row_img_expected_replica = | 1:1 2:2
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c2=3, c3='bbbbb' WHERE c2=2
-- let $row_img_expected_primary= 1:1 2:2 | 2:3 3:'bbbbb'
-- let $row_img_expected_replica = 1:1 | 2:3
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ##################################################################
-- echo # Test that replica fills default columns in its own columns
-- echo ##################################################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:FULL:N,replica:FULL:Y
-- source include/rpl_row_img_set.inc

SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int, c2 int);
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int, c2 int, c3 int DEFAULT 2005);

-- connection primary

-- let $row_img_query= INSERT INTO t(c1) VALUES (1)
-- let $row_img_expected_primary= | 1:1 2:NULL
-- let $row_img_expected_replica = | 1:1 2:NULL 3:2005
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= INSERT INTO t(c1) VALUES (2)
-- let $row_img_expected_primary= | 1:2 2:NULL
-- let $row_img_expected_replica = | 1:2 2:NULL 3:2005
-- source include/rpl_row_img_parts_primary_replica.inc

-- connection replica
SELECT * FROM t;
-- connection primary
SELECT * FROM t;

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ##################################################################
-- echo # Test that replica uses partial BI when primary contains more columns
-- echo ##################################################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:MINIMAL:Y
-- source include/rpl_row_img_set.inc


SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, primary key(c1, c3), unique key(c1));
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int NOT NULL, c2 int, unique key(c1));

-- connection primary

-- let $row_img_query= INSERT INTO t VALUES (1, 2, 3)
-- let $row_img_expected_primary= | 1:1 2:2 3:3
-- let $row_img_expected_replica = | 1:1 2:2
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c2= 4 WHERE c1=1
-- let $row_img_expected_primary= 1:1 3:3 | 2:4
-- let $row_img_expected_replica = 1:1 | 2:4
-- source include/rpl_row_img_parts_primary_replica.inc

-- connection replica
SELECT * FROM t;
-- connection primary
SELECT * FROM t;

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ##################################################################
-- echo # Test that if primary has binlog_row_image=MINIMAL and replica has 
-- echo # NOBLOB or FULL, it will log the expected columns
-- echo ##################################################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:FULL:Y
-- source include/rpl_row_img_set.inc

SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, primary key(c1));
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, c4 blob, unique key(c1));

-- connection primary
-- let $row_img_query= INSERT INTO t VALUES (1, 2, 3)
-- let $row_img_expected_primary= | 1:1 2:2 3:3
-- let $row_img_expected_replica = | 1:1 2:2 3:3 4:NULL
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c2= 4 WHERE c1=1
-- let $row_img_expected_primary=  1:1 | 2:4
-- let $row_img_expected_replica = 1:1 2:2 3:3 4:NULL | 1:1 2:4 3:3 4:NULL
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= DELETE FROM t WHERE c2=4
-- let $row_img_expected_primary= 1:1 |
-- let $row_img_expected_replica = 1:1 2:4 3:3 4:NULL | 
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:NOBLOB:Y
-- source include/rpl_row_img_set.inc

SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, primary key(c1));
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, c4 blob, unique key(c1));

-- connection primary
-- let $row_img_query= INSERT INTO t VALUES (1, 2, 3)
-- let $row_img_expected_primary= | 1:1 2:2 3:3
-- let $row_img_expected_replica = | 1:1 2:2 3:3
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= UPDATE t SET c2= 4 WHERE c1=1
-- let $row_img_expected_primary= 1:1 | 2:4
-- let $row_img_expected_replica = 1:1 2:2 3:3 | 1:1 2:4 3:3
-- source include/rpl_row_img_parts_primary_replica.inc

-- let $row_img_query= DELETE FROM t WHERE c2=4
-- let $row_img_expected_primary= 1:1 |
-- let $row_img_expected_replica = 1:1 2:4 3:3 | 
-- source include/rpl_row_img_parts_primary_replica.inc

DROP TABLE t;
--source include/sync_replica_sql_with_primary.inc

-- echo ################################################################
-- echo # Test that the replica stop with error if no usable data is on BI
-- echo ################################################################

-- source include/rpl_reset.inc
-- connection primary
-- let $row_img_set=primary:MINIMAL:N,replica:NOBLOB:Y
-- source include/rpl_row_img_set.inc

SET SQL_LOG_BIN=0;
CREATE TABLE t (c1 int NOT NULL, c2 int, c3 int, primary key(c3));
SET SQL_LOG_BIN=1;

-- connection replica
CREATE TABLE t (c1 int NOT NULL, c2 int, primary key(c1));

-- connection primary

INSERT INTO t VALUES (1,2,3);
UPDATE t SET c2=4 WHERE c2=2;
DROP TABLE t;

-- connection replica
# 1032==ER_KEY_NOT_FOUND (handler returns HA_ERR_END_OF_FILE)
let $replica_sql_errno= 1032;
source include/wait_for_replica_sql_error.inc;
DROP TABLE t;
--let $rpl_only_running_threads= 1
-- source include/rpl_reset.inc

## CLEAN UP

-- connection primary
SET GLOBAL binlog_row_image= @old_binlog_row_image;
SET SESSION binlog_row_image= @old_binlog_row_image;
-- connection replica
SET GLOBAL binlog_row_image= @old_binlog_row_image;
SET SESSION binlog_row_image= @old_binlog_row_image;

--source include/rpl_end.inc
