#Want to skip this test from daily Valgrind execution
--source include/no_valgrind_without_big.inc

# Needed because test uses CREATE TEMPORARY/DROP TEMPORARY inside transaction
source include/not_gtid_enabled.inc;
source include/primary-replica.inc;
source include/have_innodb.inc;
source include/have_myisam.inc;
source include/have_debug.inc;
source include/have_debug_sync.inc;
source include/have_binlog_format_mixed_or_statement.inc;

--echo
--echo # BUG#56118 STOP REPLICA does not wait till trx with CREATE TMP TABLE ends
--echo #
--echo # If a temporary table is created or dropped, the transaction should be
--echo # regarded similarly that a non-transactional table is modified. So 
--echo # STOP REPLICA should wait until the transaction has finished.

CREATE TABLE t1(c1 INT) ENGINE=InnoDB;
CREATE TABLE t2(c1 INT) ENGINE=InnoDB;

--source include/sync_replica_sql_with_primary.inc
SET DEBUG_SYNC= 'RESET';
source include/stop_replica.inc;

--echo
--echo # Suspend the INSERT statement in current transaction on SQL thread.
--echo # It guarantees that SQL thread is applying the transaction when
--echo # STOP REPLICA command launchs.
let $debug_save= `SELECT @@GLOBAL.debug`;
SET GLOBAL debug= 'd,after_mysql_insert';
source include/start_replica.inc;

--echo
--echo # CREATE TEMPORARY TABLE with InnoDB engine
--echo # -----------------------------------------
let $tmp_table_stm= CREATE TEMPORARY TABLE tt1(c1 INT) ENGINE = InnoDB;
source extra/rpl_tests/rpl_stop_replica.test;

--echo
--echo # CREATE TEMPORARY TABLE ... SELECT with InnoDB engine
--echo # ----------------------------------------------------
let $tmp_table_stm= CREATE TEMPORARY TABLE tt1(c1 INT) ENGINE = InnoDB
                    SELECT c1 FROM t2;
source extra/rpl_tests/rpl_stop_replica.test;

# Don't need to verify 'CREATE TEMPORARY TABLE' with MyIASM engine, as it
# never is binlogged into a transaction since 5.5.

--echo
--echo # Test end
SET GLOBAL debug= '$debug_save';
source include/restart_replica_sql.inc;

connection replica;
call mtr.add_suppression("Replica SQL.*Request to stop replica SQL Thread received while applying a group that has non-transactional changes; waiting for completion of the group");
call mtr.add_suppression("The replica coordinator and worker threads are stopped, possibly leaving data in inconsistent state");
connection primary;

--source include/rpl_connection_primary.inc
DROP TABLE t1, t2;

--echo
--echo # Bug#58546 test rpl_packet timeout failure sporadically on PB
--echo # ----------------------------------------------------------------------
--echo # STOP REPLICA stopped IO thread first and then stopped SQL thread. It was
--echo # possible that IO thread stopped after replicating part of a transaction
--echo # which SQL thread was executing. SQL thread would be hung if the
--echo # transaction could not be rolled back safely.
--echo # It caused some sporadic failures on PB2.
--echo #
--echo # This test verifies that when 'STOP REPLICA' is issued by a user, IO
--echo # thread will continue to fetch the rest events of the transaction which
--echo # is being executed by SQL thread and is not able to be rolled back safely.

CREATE TABLE t1 (c1 INT KEY, c2 INT) ENGINE=InnoDB;
CREATE TABLE t2 (c1 INT) ENGINE=MyISAM;
INSERT INTO t1 VALUES(1, 1);

--source include/sync_replica_sql_with_primary.inc
--source include/stop_replica.inc

--source include/rpl_connection_primary.inc
# make sure that there are no zombie threads
--source include/stop_dump_threads.inc

let $debug_save= `SELECT @@GLOBAL.debug`;
SET GLOBAL debug= 'd,dump_thread_wait_before_send_xid';

--source include/rpl_connection_replica.inc
--source include/start_replica.inc

BEGIN;
UPDATE t1 SET c2 = 2 WHERE c1 = 1;

--source include/rpl_connection_primary.inc
BEGIN;
INSERT INTO t1 VALUES(2, 2);
INSERT INTO t2 VALUES(1);
UPDATE t1 SET c2 = 3 WHERE c1 = 1;
COMMIT;

# wait for the dump thread reach the sync point
--let $wait_condition= select count(*)=1 from information_schema.processlist where state LIKE '%debug sync point%' and command='Binlog Dump'
--source include/wait_condition.inc

--source include/rpl_connection_replica1.inc
let $show_statement= SHOW PROCESSLIST;
let $field= Info;
let $condition= = 'UPDATE t1 SET c2 = 3 WHERE c1 = 1';
source include/wait_show_condition.inc;

send STOP REPLICA;

--source include/rpl_connection_replica.inc
ROLLBACK;

--source include/rpl_connection_primary.inc

SET DEBUG_SYNC= 'now SIGNAL signal.continue';
# wait for the dump thread to come out of the
# waiting phase before resetting the signals
--let $wait_condition= select count(*)=0 from information_schema.processlist where state LIKE '%debug sync point%' and command='Binlog Dump'
--source include/wait_condition.inc
SET DEBUG_SYNC= 'RESET';

--source include/rpl_connection_replica.inc
source include/wait_for_replica_to_stop.inc;

--source include/rpl_connection_replica1.inc
reap;

# Replica has stopped, thence lets make sure that
# we kill the zombie dump threads. Also, make
# sure that we disable the DBUG_EXECUTE_IF
# that would set the dump thread to wait
--source include/rpl_connection_primary.inc
SET GLOBAL debug= '$debug_save';
# make sure that there are no zombie threads
--source include/stop_dump_threads.inc

--source include/rpl_connection_replica1.inc
# now the dump thread on the primary will start
# from a clean slate, i.e. without the
# DBUG_EXECUTE_IF set
source include/start_replica.inc;

--source include/rpl_connection_primary.inc
DROP TABLE t1, t2;
--source include/rpl_end.inc
